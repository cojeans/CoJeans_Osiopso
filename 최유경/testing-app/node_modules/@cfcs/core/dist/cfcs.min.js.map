{"version":3,"file":"cfcs.min.js","sources":["../src/core/utils.ts","../src/reactive/const.ts","../src/reactive/detectDependencies.ts","../src/reactive/Observer.ts","../src/reactive/ComputedObserver.ts","../src/reactive/decorators/Observe.ts","../src/reactive/decorators/ReactiveSubscribe.ts","../src/reactive/inline.ts","../src/reactive/utils.ts","../src/dom/utils.ts","../src/reactive/adaptReactive.ts","../src/reactive/decorators/Computed.ts"],"sourcesContent":["/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nexport function keys<T extends Record<string, any>>(obj: T): Array<keyof T> {\n  return Object.keys(obj);\n}\n\nexport function camelize(str: string) {\n  return str.replace(/[\\s-_]([a-z])/g, (all, letter) => letter.toUpperCase());\n}\n\nexport function isString(val: any): val is string {\n  return typeof val === \"string\";\n}\n\nexport function isObject(val: any): val is object {\n  return typeof val === \"object\";\n}\n\nexport function isFunction(val: any): val is Function {\n  return typeof val === \"function\";\n}\n","export const OBSERVERS_PATH = \"__observers__\";\nexport const REACTIVE_PATH = \"__reactive__\";\nexport const CFCS_DETECTED_DEPENDENCIES_VERSION = 1;\nexport const CFCS_DETECTED_DEPENDENCIES = \"__CFCS_DETECTED_DEPENDENCIES__\";\n","import {\n  CFCS_DETECTED_DEPENDENCIES,\n  CFCS_DETECTED_DEPENDENCIES_VERSION,\n} from \"./const\";\nimport { Observer } from \"./Observer\";\n\nexport interface Detected {\n  host: Observer<any>;\n  observers: Array<Observer<any>>;\n  push(observer: Observer<any>): void;\n}\n\nexport function getDetectedStack(): Array<Detected> {\n  // Version issues do not occur when you access the native object in the global.\n  (Object as any)[CFCS_DETECTED_DEPENDENCIES] = (Object as any)[CFCS_DETECTED_DEPENDENCIES] || {};\n  const versionList = (Object as any)[CFCS_DETECTED_DEPENDENCIES];\n\n  versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];\n\n  return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];\n}\n\nexport function getCurrentDetected(): Detected | undefined {\n  const stack = getDetectedStack();\n\n  return stack[stack.length - 1];\n}\n\nexport function detectDependencies(host: Observer<any>) {\n  const stack = getDetectedStack();\n  const observers: Array<Observer> = [];\n  const detected: Detected = {\n    host,\n    observers,\n    push(observer: Observer<any>) {\n      if (host !== observer && observers.indexOf(observer) === -1) {\n        observers.push(observer);\n      }\n    },\n  };\n\n  stack.push(detected);\n  return detected;\n}\n\nexport function endDetectDependencies() {\n  const stack = getDetectedStack();\n\n  return stack.pop();\n}\n","import Component from \"@egjs/component\";\nimport { getCurrentDetected } from \"./detectDependencies\";\n\ninterface EmitterEvents<Value> {\n  update: (value: Value, prevValue: Value) => void;\n}\n\n/**\n * @memberof Reactive\n */\nexport class Observer<Value = any> {\n  protected _current: Value;\n  protected _emitter = new Component<EmitterEvents<Value>>();\n\n  /**\n   *\n   */\n  constructor(value?: Value) {\n    this._current = value as any;\n  }\n  public get current() {\n    const currentDetected = getCurrentDetected();\n\n    currentDetected?.push(this);\n    return this._current as Value;\n  }\n  public set current(value: Value) {\n    this._setCurrent(value);\n  }\n  public subscribe(callback: (value: Value, prevValue: Value) => void) {\n    this.current;\n    this._emitter.on(\"update\", callback);\n    return this;\n  }\n  public unsubscribe(callback?: (value: Value, prevValue: Value) => void) {\n    this._emitter.off(\"update\", callback);\n    return this;\n  }\n  protected _setCurrent(value: Value) {\n    const prevValue = this._current;\n    const isUpdate = value !== prevValue;\n\n    this._current = value;\n\n    if (isUpdate) {\n      this._emitter.trigger(\"update\", value, prevValue);\n    }\n  }\n  public toString() {\n    return `${this.current}`;\n  }\n  public valueOf() {\n    return this.current;\n  }\n}\n","import { detectDependencies, endDetectDependencies } from \"./detectDependencies\";\nimport { Observer } from \"./Observer\";\n\n/**\n * @memberof Reactive\n * @extends Reactive.Observer\n */\nexport class ComputedObserver<T> extends Observer<T> {\n  private _registered: Array<Observer<any>> = [];\n  /**\n   * Creates a new computed observer from the values of other observers.\n   * It is read-only and if you change the value of the observer used inside the callback, its value will be automatically updated.\n   * @param _computedCallback A function for observers to be computed.\n   */\n  constructor(private _computedCallback: () => T) {\n    super();\n\n    this._current = this.current;\n  }\n\n  get current() {\n    detectDependencies(this);\n    const value = this._computedCallback();\n    const results = endDetectDependencies()!;\n\n    this._registered.forEach(observer => {\n      observer.unsubscribe(this._onCheckUpdate);\n    });\n    results.observers.forEach(observer => {\n      observer.subscribe(this._onCheckUpdate);\n    });\n    this._registered = results.observers;\n\n    return value;\n  }\n\n  private _onCheckUpdate = () => {\n    this._setCurrent(this.current);\n  }\n}\n","import { getObserver } from \"../utils\";\n\n\nfunction injectObserve(prototype: any, memberName: string, publicName = memberName) {\n  const nextAttributes: PropertyDescriptor = {\n    configurable: true,\n    get: function () {\n      return getObserver(this, publicName).current;\n    },\n    set: function (value: any) {\n      getObserver(this, publicName, value).current = value;\n    },\n  };\n  Object.defineProperty(prototype, memberName, nextAttributes);\n  if (publicName !== memberName) {\n    Object.defineProperty(prototype, publicName, {\n      configurable: true,\n      get: function () {\n        return getObserver(this, publicName).current;\n      },\n    });\n  }\n}\nexport function Observe(protoype: any, memberName: string): void;\nexport function Observe(name?: string): (protoype: any, memberName: string) => void;\nexport function Observe(...args: any[]) {\n  if (args.length > 1) {\n    return injectObserve(args[0], args[1]);\n  }\n\n  return (prototype: any, memberName: string) => injectObserve(prototype, memberName, args[0]);\n}\n\n\nexport function Reactive(protoype: any, memberName: string): void;\nexport function Reactive(name?: string): (protoype: any, memberName: string) => void;\nexport function Reactive(...args: any[]) {\n  return Observe(...args);\n}\n\n","import { keys } from \"../../core\";\nimport { getObserver, getObservers } from \"../utils\";\n\nexport function injectReactiveSubscribe(object: Record<string, any>,) {\n  object[\"subscribe\"] = function (name: string, callback: (value: any) => void) {\n    this[name];\n    getObserver(this, name).subscribe(callback);\n  };\n  object[\"unsubscribe\"] = function (name?: string, callback?: (value: any) => void) {\n    if (!name) {\n      keys(getObservers(this)).forEach((observerName) => {\n        this.unsubscribe(observerName);\n      });\n      return;\n    }\n    if (!(name in this)) {\n      return;\n    }\n    getObserver(this, name).unsubscribe(callback);\n  };\n}\n\nexport function ReactiveSubscribe(Constructor: any) {\n  const prototype = Constructor.prototype;\n\n  injectReactiveSubscribe(prototype);\n}\n\n/**\n * @typedef\n */\nexport interface ReactiveSubscribe<State extends Record<string, any>> {\n  /**\n   * When the value of the property changes, the callback function is called.\n   */\n  subscribe<Name extends keyof State = keyof State>(\n    name: Name, callback: (value: State[Name]) => void): void;\n  /**\n   * Unregister the callback function corresponding to the property.\n   */\n  unsubscribe<Name extends keyof State = keyof State>(\n    name?: Name, callback?: (value: State[Name]) => void): void;\n}\n","import { ComputedObserver } from \"./ComputedObserver\";\nimport { Observer } from \"./Observer\";\nimport { ExtractNever, isFunction, keys } from \"../core\";\nimport { Observe } from \"./decorators/Observe\";\nimport { injectReactiveSubscribe, ReactiveSubscribe } from \"./decorators/ReactiveSubscribe\";\nimport { defineObservers, isObserver, setObserver } from \"./utils\";\n\n\ntype ConvertValue<Object extends Record<string, any>> = {\n  [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : Object[Key];\n}\n\ntype PickObverser<Object extends Record<string, any>> = ExtractNever<{\n  [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : never;\n}>;\n\nexport type ReactiveObject<Object extends Record<string, any>>\n  = ConvertValue<Object> & ReactiveSubscribe<PickObverser<Object>>;\n\nexport function reactive<Object extends Record<string, any>>(\n  setup: Readonly<Object> | (() => Readonly<Object>),\n  all?: boolean,\n): ReactiveObject<Object> {\n  const result = isFunction(setup) ? setup() : setup;\n  const reactiveObject: Record<string, any> = {};\n\n  defineObservers(reactiveObject);\n  keys(result).forEach((name: any) => {\n    const value = result[name];\n\n    if (isObserver(value)) {\n      setObserver(reactiveObject, name, value);\n    } else if (!all) {\n      reactiveObject[name] = value;\n      return;\n    } else {\n      setObserver(reactiveObject, name, observe(value));\n    }\n    Observe(name)(reactiveObject, name);\n  });\n\n  injectReactiveSubscribe(reactiveObject);\n  return reactiveObject as ReactiveObject<Object>;\n}\n\nexport function computed<Type>(computedCallback: () => Type) {\n    return new ComputedObserver(computedCallback);\n}\n\nexport function observe<Type>(defaultValue?: Type): Observer<Type> {\n    return new Observer<Type>(defaultValue);\n}\n","import { OBSERVERS_PATH } from \"./const\";\nimport { Observer } from \"./Observer\";\nimport { ReactiveMethods } from \"./types\";\nimport { isObject, Ref } from \"../core\";\nimport { observe } from \"./inline\";\n\n\nexport function withReactiveMethods<\n  Instance,\n  Names extends keyof Partial<Instance>,\n  Return extends ReactiveMethods<Instance, Names>\n>(ref: Ref<Instance>, methods?: readonly Names[]): Return {\n  const obj: Record<any, any> = {};\n\n  if (!methods) {\n    return obj;\n  }\n\n  methods.forEach(name => {\n    obj[name] = function (...args: any[]) {\n      const current: any = ref.current || ref.value;\n\n      return current[name](...args);\n    };\n  });\n  return obj as Return;\n}\n\n\nexport function defineObservers(instance: any) {\n  const observers: Record<string, Observer<any>> = {};\n\n  Object.defineProperty(instance, OBSERVERS_PATH, {\n    get() {\n      return observers;\n    },\n  });\n\n  return observers;\n}\n\nexport function getObservers(instance: any): Record<string, Observer<any>> {\n  if (!instance[OBSERVERS_PATH]) {\n    defineObservers(instance);\n  }\n  return instance[OBSERVERS_PATH];\n}\n\nexport function getObserver(instance: any, name: string, defaultValue?: any): Observer<any> {\n  const observers = getObservers(instance);\n\n  if (!observers[name]) {\n    observers[name] = observe(defaultValue);\n  }\n  return observers[name];\n}\n\nexport function setObserver(instance: any, name: string, observer: Observer<any>) {\n  const observers = getObservers(instance);\n\n  observers[name] = observer;\n}\n\nexport function isObserver(val: any): val is Observer {\n  return val && isObject(val) && (\"current\" in val && \"subscribe\" in val && \"unsubscribe\" in val);\n}\n\n","import { isString, Ref } from \"../core\";\n\nexport function findTarget<Target extends Element = Element>(target: string | Target | Ref<Target> | null): Target | null {\n  let el!: Target;\n\n  if (!target) {\n    return null;\n  } if (isString(target)) {\n    el = document.querySelector<Target>(target)!;\n  } else if (target instanceof Element) {\n    el = target;\n  } else if (\"value\" in target || \"current\" in target) {\n    el = target.value! || target.current!;\n  }\n\n  return el;\n}\n\nexport function withClassMethods(methods: readonly string[]) {\n  return function (prototype: any, memberName: string) {\n    methods.forEach((name: string) => {\n      if (name in prototype) {\n        return;\n      }\n      prototype[name] = function (...args) {\n        const result = this[memberName][name](...args);\n\n        // fix `this` type to return your own `class` instance to the instance using the decorator.\n        if (result === this[memberName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n","import { keys } from \"../core\";\nimport { Ref } from \"../core/types\";\nimport { ReactiveAdapter } from \"./ReactiveAdapter\";\nimport { ReactiveSubscribe } from \"./decorators/ReactiveSubscribe\";\nimport { ReactiveEventCallback } from \"./types\";\nimport { getObservers, withReactiveMethods } from \"./utils\";\n\nexport function adaptReactive<\n  Instance extends ReactiveSubscribe<Record<string, any>>,\n  State extends Record<string, any> = {},\n  Methods extends keyof Partial<Instance> = any,\n  Data = any,\n  Events extends Record<string, any> = {},\n  >(adapter: ReactiveAdapter<Instance, State, Methods, Data, Events>) {\n\n  function data(): Data {\n    return adapter.data?.() ?? {} as Data;\n  }\n\n  const instanceRef: Ref<Instance> = { current: adapter.created?.(data()) || null };\n  let firstState: State | null = null;\n\n  return {\n    state(): State {\n      const inst = instanceRef.current;\n\n      if (firstState) {\n        return firstState;\n      }\n      if (adapter.state) {\n        firstState = adapter.state;\n      } else if (inst) {\n        const observers = getObservers(inst);\n\n        firstState = keys(observers).reduce((prev, cur) => {\n          prev[cur] = observers[cur].current;\n          return prev;\n        }, {} as any);\n      }\n      return firstState || {} as State;\n    },\n    instance() {\n      return instanceRef.current;\n    },\n    mounted(): void {\n      instanceRef.current = adapter.mounted?.(data(), instanceRef.current) || instanceRef.current;\n    },\n    init(): void {\n      adapter.init?.(instanceRef.current!, data());\n    },\n    destroy(): void {\n      adapter.destroy?.(instanceRef.current!, data());\n    },\n    methods() {\n      return withReactiveMethods<any, any, any>(instanceRef, adapter.methods);\n    },\n    on(eventName: string, listener: ReactiveEventCallback<any, any>) {\n      adapter.on?.(instanceRef.current!, eventName as never, listener);\n    },\n    off(eventName: string, listener: ReactiveEventCallback<any, any>) {\n      adapter.off?.(instanceRef.current!, eventName as never, listener);\n    },\n  };\n}\n","import { computed } from \"../inline\";\nimport { getObserver, getObservers } from \"../utils\";\n\n\nexport function Computed(prototype: any, memberName: string, attributes: PropertyDescriptor): PropertyDescriptor {\n    const get = attributes.get!;\n    function getComputed() {\n        const observers = getObservers(this);\n\n        if (!(memberName in observers)) {\n            observers[memberName] = computed(get.bind(this));\n        }\n        return getObserver(this, memberName).current;\n    }\n    const nextAttributes: PropertyDescriptor = {\n        configurable: true,\n        get: getComputed,\n    }\n\n    Object.defineProperty(prototype, memberName, nextAttributes);\n\n    return nextAttributes;\n}\n"],"names":["keys","obj","Object","isString","val","isObject","isFunction","OBSERVERS_PATH","CFCS_DETECTED_DEPENDENCIES_VERSION","CFCS_DETECTED_DEPENDENCIES","getDetectedStack","versionList","Observer","value","this","_emitter","Component","_current","__proto","prototype","defineProperty","get","currentDetected","stack","length","push","set","_setCurrent","subscribe","callback","current","on","unsubscribe","off","prevValue","isUpdate","trigger","toString","concat","valueOf","ComputedObserver","_super","__extends","_computedCallback","_this","_registered","_onCheckUpdate","host","observers","detected","observer","indexOf","results","pop","forEach","injectObserve","memberName","publicName","configurable","getObserver","Observe","args","_i","arguments","injectReactiveSubscribe","object","name","getObservers","observerName","computed","computedCallback","observe","defaultValue","withReactiveMethods","ref","methods","defineObservers","instance","setObserver","isObserver","str","replace","all","letter","toUpperCase","target","el","document","querySelector","Element","result","_a","apply","setup","reactiveObject","adapter","data","_b","call","instanceRef","created","firstState","state","observers_1","inst","reduce","prev","cur","mounted","init","destroy","eventName","listener","attributes","nextAttributes","bind","Constructor"],"mappings":"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"}