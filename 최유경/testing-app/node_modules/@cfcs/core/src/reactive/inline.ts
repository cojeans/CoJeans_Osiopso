import { ComputedObserver } from "./ComputedObserver";
import { Observer } from "./Observer";
import { ExtractNever, isFunction, keys } from "../core";
import { Observe } from "./decorators/Observe";
import { injectReactiveSubscribe, ReactiveSubscribe } from "./decorators/ReactiveSubscribe";
import { defineObservers, isObserver, setObserver } from "./utils";


type ConvertValue<Object extends Record<string, any>> = {
  [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : Object[Key];
}

type PickObverser<Object extends Record<string, any>> = ExtractNever<{
  [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : never;
}>;

export type ReactiveObject<Object extends Record<string, any>>
  = ConvertValue<Object> & ReactiveSubscribe<PickObverser<Object>>;

export function reactive<Object extends Record<string, any>>(
  setup: Readonly<Object> | (() => Readonly<Object>),
  all?: boolean,
): ReactiveObject<Object> {
  const result = isFunction(setup) ? setup() : setup;
  const reactiveObject: Record<string, any> = {};

  defineObservers(reactiveObject);
  keys(result).forEach((name: any) => {
    const value = result[name];

    if (isObserver(value)) {
      setObserver(reactiveObject, name, value);
    } else if (!all) {
      reactiveObject[name] = value;
      return;
    } else {
      setObserver(reactiveObject, name, observe(value));
    }
    Observe(name)(reactiveObject, name);
  });

  injectReactiveSubscribe(reactiveObject);
  return reactiveObject as ReactiveObject<Object>;
}

export function computed<Type>(computedCallback: () => Type) {
    return new ComputedObserver(computedCallback);
}

export function observe<Type>(defaultValue?: Type): Observer<Type> {
    return new Observer<Type>(defaultValue);
}
