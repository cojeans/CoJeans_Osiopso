{"ast":null,"code":"/*\nCopyright (c) NAVER Crop.\nname: @cfcs/core\nlicense: MIT\nauthor: NAVER Crop.\nrepository: https://github.com/naver/cfcs\nversion: 0.0.12\n*/\nimport Component from '@egjs/component';\n\n/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nfunction keys(obj) {\n  return Object.keys(obj);\n}\nfunction camelize(str) {\n  return str.replace(/[\\s-_]([a-z])/g, function (all, letter) {\n    return letter.toUpperCase();\n  });\n}\nfunction isString(val) {\n  return typeof val === \"string\";\n}\nfunction isObject(val) {\n  return typeof val === \"object\";\n}\nfunction isFunction(val) {\n  return typeof val === \"function\";\n}\nfunction findTarget(target) {\n  var el;\n  if (!target) {\n    return null;\n  }\n  if (isString(target)) {\n    el = document.querySelector(target);\n  } else if (target instanceof Element) {\n    el = target;\n  } else if (\"value\" in target || \"current\" in target) {\n    el = target.value || target.current;\n  }\n  return el;\n}\nfunction withClassMethods(methods) {\n  return function (prototype, memberName) {\n    methods.forEach(function (name) {\n      if (name in prototype) {\n        return;\n      }\n      prototype[name] = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var result = (_a = this[memberName])[name].apply(_a, args); // fix `this` type to return your own `class` instance to the instance using the decorator.\n\n        if (result === this[memberName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\nvar OBSERVERS_PATH = \"__observers__\";\nvar CFCS_DETECTED_DEPENDENCIES_VERSION = 1;\nvar CFCS_DETECTED_DEPENDENCIES = \"__CFCS_DETECTED_DEPENDENCIES__\";\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction getDetectedStack() {\n  // Version issues do not occur when you access the native object in the global.\n  Object[CFCS_DETECTED_DEPENDENCIES] = Object[CFCS_DETECTED_DEPENDENCIES] || {};\n  var versionList = Object[CFCS_DETECTED_DEPENDENCIES];\n  versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];\n  return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];\n}\nfunction getCurrentDetected() {\n  var stack = getDetectedStack();\n  return stack[stack.length - 1];\n}\nfunction detectDependencies(host) {\n  var stack = getDetectedStack();\n  var observers = [];\n  var detected = {\n    host: host,\n    observers: observers,\n    push: function (observer) {\n      if (host !== observer && observers.indexOf(observer) === -1) {\n        observers.push(observer);\n      }\n    }\n  };\n  stack.push(detected);\n  return detected;\n}\nfunction endDetectDependencies() {\n  var stack = getDetectedStack();\n  return stack.pop();\n}\n\n/**\n * @memberof Reactive\n */\n\nvar Observer = /*#__PURE__*/\nfunction () {\n  /**\n   *\n   */\n  function Observer(value) {\n    this._emitter = new Component();\n    this._current = value;\n  }\n  var __proto = Observer.prototype;\n  Object.defineProperty(__proto, \"current\", {\n    get: function () {\n      var currentDetected = getCurrentDetected();\n      currentDetected === null || currentDetected === void 0 ? void 0 : currentDetected.push(this);\n      return this._current;\n    },\n    set: function (value) {\n      this._setCurrent(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  __proto.subscribe = function (callback) {\n    this.current;\n    this._emitter.on(\"update\", callback);\n    return this;\n  };\n  __proto.unsubscribe = function (callback) {\n    this._emitter.off(\"update\", callback);\n    return this;\n  };\n  __proto._setCurrent = function (value) {\n    var prevValue = this._current;\n    var isUpdate = value !== prevValue;\n    this._current = value;\n    if (isUpdate) {\n      this._emitter.trigger(\"update\", value, prevValue);\n    }\n  };\n  __proto.toString = function () {\n    return \"\".concat(this.current);\n  };\n  __proto.valueOf = function () {\n    return this.current;\n  };\n  return Observer;\n}();\n\n/**\n * @memberof Reactive\n * @extends Reactive.Observer\n */\n\nvar ComputedObserver = /*#__PURE__*/\nfunction (_super) {\n  __extends(ComputedObserver, _super);\n  /**\n   * Creates a new computed observer from the values of other observers.\n   * It is read-only and if you change the value of the observer used inside the callback, its value will be automatically updated.\n   * @param _computedCallback A function for observers to be computed.\n   */\n\n  function ComputedObserver(_computedCallback) {\n    var _this = _super.call(this) || this;\n    _this._computedCallback = _computedCallback;\n    _this._registered = [];\n    _this._onCheckUpdate = function () {\n      _this._setCurrent(_this.current);\n    };\n    _this._current = _this.current;\n    return _this;\n  }\n  var __proto = ComputedObserver.prototype;\n  Object.defineProperty(__proto, \"current\", {\n    get: function () {\n      var _this = this;\n      detectDependencies(this);\n      var value = this._computedCallback();\n      var results = endDetectDependencies();\n      this._registered.forEach(function (observer) {\n        observer.unsubscribe(_this._onCheckUpdate);\n      });\n      results.observers.forEach(function (observer) {\n        observer.subscribe(_this._onCheckUpdate);\n      });\n      this._registered = results.observers;\n      return value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ComputedObserver;\n}(Observer);\nfunction injectObserve(prototype, memberName, publicName) {\n  if (publicName === void 0) {\n    publicName = memberName;\n  }\n  var nextAttributes = {\n    configurable: true,\n    get: function () {\n      return getObserver(this, publicName).current;\n    },\n    set: function (value) {\n      getObserver(this, publicName, value).current = value;\n    }\n  };\n  Object.defineProperty(prototype, memberName, nextAttributes);\n  if (publicName !== memberName) {\n    Object.defineProperty(prototype, publicName, {\n      configurable: true,\n      get: function () {\n        return getObserver(this, publicName).current;\n      }\n    });\n  }\n}\nfunction Observe() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  if (args.length > 1) {\n    return injectObserve(args[0], args[1]);\n  }\n  return function (prototype, memberName) {\n    return injectObserve(prototype, memberName, args[0]);\n  };\n}\nfunction Reactive() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  return Observe.apply(void 0, args);\n}\nfunction injectReactiveSubscribe(object) {\n  object[\"subscribe\"] = function (name, callback) {\n    this[name];\n    getObserver(this, name).subscribe(callback);\n  };\n  object[\"unsubscribe\"] = function (name, callback) {\n    var _this = this;\n    if (!name) {\n      keys(getObservers(this)).forEach(function (observerName) {\n        _this.unsubscribe(observerName);\n      });\n      return;\n    }\n    if (!(name in this)) {\n      return;\n    }\n    getObserver(this, name).unsubscribe(callback);\n  };\n}\nfunction ReactiveSubscribe(Constructor) {\n  var prototype = Constructor.prototype;\n  injectReactiveSubscribe(prototype);\n}\nfunction reactive(setup, all) {\n  var result = isFunction(setup) ? setup() : setup;\n  var reactiveObject = {};\n  defineObservers(reactiveObject);\n  keys(result).forEach(function (name) {\n    var value = result[name];\n    if (isObserver(value)) {\n      setObserver(reactiveObject, name, value);\n    } else if (!all) {\n      reactiveObject[name] = value;\n      return;\n    } else {\n      setObserver(reactiveObject, name, observe(value));\n    }\n    Observe(name)(reactiveObject, name);\n  });\n  injectReactiveSubscribe(reactiveObject);\n  return reactiveObject;\n}\nfunction computed(computedCallback) {\n  return new ComputedObserver(computedCallback);\n}\nfunction observe(defaultValue) {\n  return new Observer(defaultValue);\n}\nfunction withReactiveMethods(ref, methods) {\n  var obj = {};\n  if (!methods) {\n    return obj;\n  }\n  methods.forEach(function (name) {\n    obj[name] = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var current = ref.current || ref.value;\n      return current[name].apply(current, args);\n    };\n  });\n  return obj;\n}\nfunction defineObservers(instance) {\n  var observers = {};\n  Object.defineProperty(instance, OBSERVERS_PATH, {\n    get: function () {\n      return observers;\n    }\n  });\n  return observers;\n}\nfunction getObservers(instance) {\n  if (!instance[OBSERVERS_PATH]) {\n    defineObservers(instance);\n  }\n  return instance[OBSERVERS_PATH];\n}\nfunction getObserver(instance, name, defaultValue) {\n  var observers = getObservers(instance);\n  if (!observers[name]) {\n    observers[name] = observe(defaultValue);\n  }\n  return observers[name];\n}\nfunction setObserver(instance, name, observer) {\n  var observers = getObservers(instance);\n  observers[name] = observer;\n}\nfunction isObserver(val) {\n  return val && isObject(val) && \"current\" in val && \"subscribe\" in val && \"unsubscribe\" in val;\n}\nfunction adaptReactive(adapter) {\n  var _a;\n  function data() {\n    var _a, _b;\n    return (_b = (_a = adapter.data) === null || _a === void 0 ? void 0 : _a.call(adapter)) !== null && _b !== void 0 ? _b : {};\n  }\n  var instanceRef = {\n    current: ((_a = adapter.created) === null || _a === void 0 ? void 0 : _a.call(adapter, data())) || null\n  };\n  var firstState = null;\n  return {\n    state: function () {\n      var inst = instanceRef.current;\n      if (firstState) {\n        return firstState;\n      }\n      if (adapter.state) {\n        firstState = adapter.state;\n      } else if (inst) {\n        var observers_1 = getObservers(inst);\n        firstState = keys(observers_1).reduce(function (prev, cur) {\n          prev[cur] = observers_1[cur].current;\n          return prev;\n        }, {});\n      }\n      return firstState || {};\n    },\n    instance: function () {\n      return instanceRef.current;\n    },\n    mounted: function () {\n      var _a;\n      instanceRef.current = ((_a = adapter.mounted) === null || _a === void 0 ? void 0 : _a.call(adapter, data(), instanceRef.current)) || instanceRef.current;\n    },\n    init: function () {\n      var _a;\n      (_a = adapter.init) === null || _a === void 0 ? void 0 : _a.call(adapter, instanceRef.current, data());\n    },\n    destroy: function () {\n      var _a;\n      (_a = adapter.destroy) === null || _a === void 0 ? void 0 : _a.call(adapter, instanceRef.current, data());\n    },\n    methods: function () {\n      return withReactiveMethods(instanceRef, adapter.methods);\n    },\n    on: function (eventName, listener) {\n      var _a;\n      (_a = adapter.on) === null || _a === void 0 ? void 0 : _a.call(adapter, instanceRef.current, eventName, listener);\n    },\n    off: function (eventName, listener) {\n      var _a;\n      (_a = adapter.off) === null || _a === void 0 ? void 0 : _a.call(adapter, instanceRef.current, eventName, listener);\n    }\n  };\n}\nfunction Computed(prototype, memberName, attributes) {\n  var get = attributes.get;\n  function getComputed() {\n    var observers = getObservers(this);\n    if (!(memberName in observers)) {\n      observers[memberName] = computed(get.bind(this));\n    }\n    return getObserver(this, memberName).current;\n  }\n  var nextAttributes = {\n    configurable: true,\n    get: getComputed\n  };\n  Object.defineProperty(prototype, memberName, nextAttributes);\n  return nextAttributes;\n}\nexport { Computed, ComputedObserver, Observe, Observer, Reactive, ReactiveSubscribe, adaptReactive, camelize, computed, defineObservers, findTarget, getObserver, getObservers, injectReactiveSubscribe, isFunction, isObject, isObserver, isString, keys, observe, reactive, setObserver, withClassMethods, withReactiveMethods };","map":{"version":3,"mappings":"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","names":["keys","obj","Object","camelize","str","replace","all","letter","toUpperCase","isString","val","isObject","isFunction","findTarget","target","el","document","querySelector","Element","value","current","withClassMethods","methods","prototype","memberName","forEach","name","args","_i","arguments","result","apply","_a","OBSERVERS_PATH","CFCS_DETECTED_DEPENDENCIES_VERSION","CFCS_DETECTED_DEPENDENCIES","getDetectedStack","versionList","getCurrentDetected","stack","length","detectDependencies","host","observers","detected","push","observer","indexOf","endDetectDependencies","pop","Component","_current","__proto","get","currentDetected","set","_setCurrent","subscribe","callback","_emitter","on","unsubscribe","off","prevValue","isUpdate","trigger","concat","Observer","__extends","_computedCallback","_super","_this","results","_registered","_onCheckUpdate","ComputedObserver","injectObserve","publicName","nextAttributes","configurable","getObserver","defineProperty","Observe","Reactive","injectReactiveSubscribe","object","getObservers","observerName","ReactiveSubscribe","Constructor","setup","reactiveObject","defineObservers","isObserver","setObserver","observe","computed","computedCallback","defaultValue","ref","instance","adaptReactive","adapter","data","_b","instanceRef","created","firstState","state","inst","observers_1","reduce","prev","cur","mounted","init","destroy","withReactiveMethods","eventName","listener","Computed","attributes","getComputed","bind"],"sources":["C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\core\\utils.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\dom\\utils.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\reactive\\const.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\reactive\\detectDependencies.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\reactive\\Observer.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\reactive\\ComputedObserver.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\reactive\\decorators\\Observe.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\reactive\\decorators\\ReactiveSubscribe.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\reactive\\inline.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\reactive\\utils.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\reactive\\adaptReactive.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\@cfcs\\core\\src\\reactive\\decorators\\Computed.ts"],"sourcesContent":["/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nexport function keys<T extends Record<string, any>>(obj: T): Array<keyof T> {\n  return Object.keys(obj);\n}\n\nexport function camelize(str: string) {\n  return str.replace(/[\\s-_]([a-z])/g, (all, letter) => letter.toUpperCase());\n}\n\nexport function isString(val: any): val is string {\n  return typeof val === \"string\";\n}\n\nexport function isObject(val: any): val is object {\n  return typeof val === \"object\";\n}\n\nexport function isFunction(val: any): val is Function {\n  return typeof val === \"function\";\n}\n","import { isString, Ref } from \"../core\";\n\nexport function findTarget<Target extends Element = Element>(target: string | Target | Ref<Target> | null): Target | null {\n  let el!: Target;\n\n  if (!target) {\n    return null;\n  } if (isString(target)) {\n    el = document.querySelector<Target>(target)!;\n  } else if (target instanceof Element) {\n    el = target;\n  } else if (\"value\" in target || \"current\" in target) {\n    el = target.value! || target.current!;\n  }\n\n  return el;\n}\n\nexport function withClassMethods(methods: readonly string[]) {\n  return function (prototype: any, memberName: string) {\n    methods.forEach((name: string) => {\n      if (name in prototype) {\n        return;\n      }\n      prototype[name] = function (...args) {\n        const result = this[memberName][name](...args);\n\n        // fix `this` type to return your own `class` instance to the instance using the decorator.\n        if (result === this[memberName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n","export const OBSERVERS_PATH = \"__observers__\";\nexport const REACTIVE_PATH = \"__reactive__\";\nexport const CFCS_DETECTED_DEPENDENCIES_VERSION = 1;\nexport const CFCS_DETECTED_DEPENDENCIES = \"__CFCS_DETECTED_DEPENDENCIES__\";\n","import {\n  CFCS_DETECTED_DEPENDENCIES,\n  CFCS_DETECTED_DEPENDENCIES_VERSION,\n} from \"./const\";\nimport { Observer } from \"./Observer\";\n\nexport interface Detected {\n  host: Observer<any>;\n  observers: Array<Observer<any>>;\n  push(observer: Observer<any>): void;\n}\n\nexport function getDetectedStack(): Array<Detected> {\n  // Version issues do not occur when you access the native object in the global.\n  (Object as any)[CFCS_DETECTED_DEPENDENCIES] = (Object as any)[CFCS_DETECTED_DEPENDENCIES] || {};\n  const versionList = (Object as any)[CFCS_DETECTED_DEPENDENCIES];\n\n  versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];\n\n  return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];\n}\n\nexport function getCurrentDetected(): Detected | undefined {\n  const stack = getDetectedStack();\n\n  return stack[stack.length - 1];\n}\n\nexport function detectDependencies(host: Observer<any>) {\n  const stack = getDetectedStack();\n  const observers: Array<Observer> = [];\n  const detected: Detected = {\n    host,\n    observers,\n    push(observer: Observer<any>) {\n      if (host !== observer && observers.indexOf(observer) === -1) {\n        observers.push(observer);\n      }\n    },\n  };\n\n  stack.push(detected);\n  return detected;\n}\n\nexport function endDetectDependencies() {\n  const stack = getDetectedStack();\n\n  return stack.pop();\n}\n","import Component from \"@egjs/component\";\nimport { getCurrentDetected } from \"./detectDependencies\";\n\ninterface EmitterEvents<Value> {\n  update: (value: Value, prevValue: Value) => void;\n}\n\n/**\n * @memberof Reactive\n */\nexport class Observer<Value = any> {\n  protected _current: Value;\n  protected _emitter = new Component<EmitterEvents<Value>>();\n\n  /**\n   *\n   */\n  constructor(value?: Value) {\n    this._current = value as any;\n  }\n  public get current() {\n    const currentDetected = getCurrentDetected();\n\n    currentDetected?.push(this);\n    return this._current as Value;\n  }\n  public set current(value: Value) {\n    this._setCurrent(value);\n  }\n  public subscribe(callback: (value: Value, prevValue: Value) => void) {\n    this.current;\n    this._emitter.on(\"update\", callback);\n    return this;\n  }\n  public unsubscribe(callback?: (value: Value, prevValue: Value) => void) {\n    this._emitter.off(\"update\", callback);\n    return this;\n  }\n  protected _setCurrent(value: Value) {\n    const prevValue = this._current;\n    const isUpdate = value !== prevValue;\n\n    this._current = value;\n\n    if (isUpdate) {\n      this._emitter.trigger(\"update\", value, prevValue);\n    }\n  }\n  public toString() {\n    return `${this.current}`;\n  }\n  public valueOf() {\n    return this.current;\n  }\n}\n","import { detectDependencies, endDetectDependencies } from \"./detectDependencies\";\nimport { Observer } from \"./Observer\";\n\n/**\n * @memberof Reactive\n * @extends Reactive.Observer\n */\nexport class ComputedObserver<T> extends Observer<T> {\n  private _registered: Array<Observer<any>> = [];\n  /**\n   * Creates a new computed observer from the values of other observers.\n   * It is read-only and if you change the value of the observer used inside the callback, its value will be automatically updated.\n   * @param _computedCallback A function for observers to be computed.\n   */\n  constructor(private _computedCallback: () => T) {\n    super();\n\n    this._current = this.current;\n  }\n\n  get current() {\n    detectDependencies(this);\n    const value = this._computedCallback();\n    const results = endDetectDependencies()!;\n\n    this._registered.forEach(observer => {\n      observer.unsubscribe(this._onCheckUpdate);\n    });\n    results.observers.forEach(observer => {\n      observer.subscribe(this._onCheckUpdate);\n    });\n    this._registered = results.observers;\n\n    return value;\n  }\n\n  private _onCheckUpdate = () => {\n    this._setCurrent(this.current);\n  }\n}\n","import { getObserver } from \"../utils\";\n\n\nfunction injectObserve(prototype: any, memberName: string, publicName = memberName) {\n  const nextAttributes: PropertyDescriptor = {\n    configurable: true,\n    get: function () {\n      return getObserver(this, publicName).current;\n    },\n    set: function (value: any) {\n      getObserver(this, publicName, value).current = value;\n    },\n  };\n  Object.defineProperty(prototype, memberName, nextAttributes);\n  if (publicName !== memberName) {\n    Object.defineProperty(prototype, publicName, {\n      configurable: true,\n      get: function () {\n        return getObserver(this, publicName).current;\n      },\n    });\n  }\n}\nexport function Observe(protoype: any, memberName: string): void;\nexport function Observe(name?: string): (protoype: any, memberName: string) => void;\nexport function Observe(...args: any[]) {\n  if (args.length > 1) {\n    return injectObserve(args[0], args[1]);\n  }\n\n  return (prototype: any, memberName: string) => injectObserve(prototype, memberName, args[0]);\n}\n\n\nexport function Reactive(protoype: any, memberName: string): void;\nexport function Reactive(name?: string): (protoype: any, memberName: string) => void;\nexport function Reactive(...args: any[]) {\n  return Observe(...args);\n}\n\n","import { keys } from \"../../core\";\nimport { getObserver, getObservers } from \"../utils\";\n\nexport function injectReactiveSubscribe(object: Record<string, any>,) {\n  object[\"subscribe\"] = function (name: string, callback: (value: any) => void) {\n    this[name];\n    getObserver(this, name).subscribe(callback);\n  };\n  object[\"unsubscribe\"] = function (name?: string, callback?: (value: any) => void) {\n    if (!name) {\n      keys(getObservers(this)).forEach((observerName) => {\n        this.unsubscribe(observerName);\n      });\n      return;\n    }\n    if (!(name in this)) {\n      return;\n    }\n    getObserver(this, name).unsubscribe(callback);\n  };\n}\n\nexport function ReactiveSubscribe(Constructor: any) {\n  const prototype = Constructor.prototype;\n\n  injectReactiveSubscribe(prototype);\n}\n\n/**\n * @typedef\n */\nexport interface ReactiveSubscribe<State extends Record<string, any>> {\n  /**\n   * When the value of the property changes, the callback function is called.\n   */\n  subscribe<Name extends keyof State = keyof State>(\n    name: Name, callback: (value: State[Name]) => void): void;\n  /**\n   * Unregister the callback function corresponding to the property.\n   */\n  unsubscribe<Name extends keyof State = keyof State>(\n    name?: Name, callback?: (value: State[Name]) => void): void;\n}\n","import { ComputedObserver } from \"./ComputedObserver\";\nimport { Observer } from \"./Observer\";\nimport { ExtractNever, isFunction, keys } from \"../core\";\nimport { Observe } from \"./decorators/Observe\";\nimport { injectReactiveSubscribe, ReactiveSubscribe } from \"./decorators/ReactiveSubscribe\";\nimport { defineObservers, isObserver, setObserver } from \"./utils\";\n\n\ntype ConvertValue<Object extends Record<string, any>> = {\n  [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : Object[Key];\n}\n\ntype PickObverser<Object extends Record<string, any>> = ExtractNever<{\n  [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : never;\n}>;\n\nexport type ReactiveObject<Object extends Record<string, any>>\n  = ConvertValue<Object> & ReactiveSubscribe<PickObverser<Object>>;\n\nexport function reactive<Object extends Record<string, any>>(\n  setup: Readonly<Object> | (() => Readonly<Object>),\n  all?: boolean,\n): ReactiveObject<Object> {\n  const result = isFunction(setup) ? setup() : setup;\n  const reactiveObject: Record<string, any> = {};\n\n  defineObservers(reactiveObject);\n  keys(result).forEach((name: any) => {\n    const value = result[name];\n\n    if (isObserver(value)) {\n      setObserver(reactiveObject, name, value);\n    } else if (!all) {\n      reactiveObject[name] = value;\n      return;\n    } else {\n      setObserver(reactiveObject, name, observe(value));\n    }\n    Observe(name)(reactiveObject, name);\n  });\n\n  injectReactiveSubscribe(reactiveObject);\n  return reactiveObject as ReactiveObject<Object>;\n}\n\nexport function computed<Type>(computedCallback: () => Type) {\n    return new ComputedObserver(computedCallback);\n}\n\nexport function observe<Type>(defaultValue?: Type): Observer<Type> {\n    return new Observer<Type>(defaultValue);\n}\n","import { OBSERVERS_PATH } from \"./const\";\nimport { Observer } from \"./Observer\";\nimport { ReactiveMethods } from \"./types\";\nimport { isObject, Ref } from \"../core\";\nimport { observe } from \"./inline\";\n\n\nexport function withReactiveMethods<\n  Instance,\n  Names extends keyof Partial<Instance>,\n  Return extends ReactiveMethods<Instance, Names>\n>(ref: Ref<Instance>, methods?: readonly Names[]): Return {\n  const obj: Record<any, any> = {};\n\n  if (!methods) {\n    return obj;\n  }\n\n  methods.forEach(name => {\n    obj[name] = function (...args: any[]) {\n      const current: any = ref.current || ref.value;\n\n      return current[name](...args);\n    };\n  });\n  return obj as Return;\n}\n\n\nexport function defineObservers(instance: any) {\n  const observers: Record<string, Observer<any>> = {};\n\n  Object.defineProperty(instance, OBSERVERS_PATH, {\n    get() {\n      return observers;\n    },\n  });\n\n  return observers;\n}\n\nexport function getObservers(instance: any): Record<string, Observer<any>> {\n  if (!instance[OBSERVERS_PATH]) {\n    defineObservers(instance);\n  }\n  return instance[OBSERVERS_PATH];\n}\n\nexport function getObserver(instance: any, name: string, defaultValue?: any): Observer<any> {\n  const observers = getObservers(instance);\n\n  if (!observers[name]) {\n    observers[name] = observe(defaultValue);\n  }\n  return observers[name];\n}\n\nexport function setObserver(instance: any, name: string, observer: Observer<any>) {\n  const observers = getObservers(instance);\n\n  observers[name] = observer;\n}\n\nexport function isObserver(val: any): val is Observer {\n  return val && isObject(val) && (\"current\" in val && \"subscribe\" in val && \"unsubscribe\" in val);\n}\n\n","import { keys } from \"../core\";\nimport { Ref } from \"../core/types\";\nimport { ReactiveAdapter } from \"./ReactiveAdapter\";\nimport { ReactiveSubscribe } from \"./decorators/ReactiveSubscribe\";\nimport { ReactiveEventCallback } from \"./types\";\nimport { getObservers, withReactiveMethods } from \"./utils\";\n\nexport function adaptReactive<\n  Instance extends ReactiveSubscribe<Record<string, any>>,\n  State extends Record<string, any> = {},\n  Methods extends keyof Partial<Instance> = any,\n  Data = any,\n  Events extends Record<string, any> = {},\n  >(adapter: ReactiveAdapter<Instance, State, Methods, Data, Events>) {\n\n  function data(): Data {\n    return adapter.data?.() ?? {} as Data;\n  }\n\n  const instanceRef: Ref<Instance> = { current: adapter.created?.(data()) || null };\n  let firstState: State | null = null;\n\n  return {\n    state(): State {\n      const inst = instanceRef.current;\n\n      if (firstState) {\n        return firstState;\n      }\n      if (adapter.state) {\n        firstState = adapter.state;\n      } else if (inst) {\n        const observers = getObservers(inst);\n\n        firstState = keys(observers).reduce((prev, cur) => {\n          prev[cur] = observers[cur].current;\n          return prev;\n        }, {} as any);\n      }\n      return firstState || {} as State;\n    },\n    instance() {\n      return instanceRef.current;\n    },\n    mounted(): void {\n      instanceRef.current = adapter.mounted?.(data(), instanceRef.current) || instanceRef.current;\n    },\n    init(): void {\n      adapter.init?.(instanceRef.current!, data());\n    },\n    destroy(): void {\n      adapter.destroy?.(instanceRef.current!, data());\n    },\n    methods() {\n      return withReactiveMethods<any, any, any>(instanceRef, adapter.methods);\n    },\n    on(eventName: string, listener: ReactiveEventCallback<any, any>) {\n      adapter.on?.(instanceRef.current!, eventName as never, listener);\n    },\n    off(eventName: string, listener: ReactiveEventCallback<any, any>) {\n      adapter.off?.(instanceRef.current!, eventName as never, listener);\n    },\n  };\n}\n","import { computed } from \"../inline\";\nimport { getObserver, getObservers } from \"../utils\";\n\n\nexport function Computed(prototype: any, memberName: string, attributes: PropertyDescriptor): PropertyDescriptor {\n    const get = attributes.get!;\n    function getComputed() {\n        const observers = getObservers(this);\n\n        if (!(memberName in observers)) {\n            observers[memberName] = computed(get.bind(this));\n        }\n        return getObserver(this, memberName).current;\n    }\n    const nextAttributes: PropertyDescriptor = {\n        configurable: true,\n        get: getComputed,\n    }\n\n    Object.defineProperty(prototype, memberName, nextAttributes);\n\n    return nextAttributes;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}