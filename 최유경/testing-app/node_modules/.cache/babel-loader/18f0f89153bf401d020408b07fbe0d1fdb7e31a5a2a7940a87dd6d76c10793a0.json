{"ast":null,"code":"/*\nCopyright (c) 2020 Daybrush\nname: overlap-area\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/overlap-area.git\nversion: 1.1.0\n*/\nimport { throttle, TINY_NUM, sum, find, getDist, getShapeDirection, findIndex } from '@daybrush/utils';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n  return r;\n}\nfunction tinyThrottle(num) {\n  return throttle(num, TINY_NUM);\n}\nfunction isSameConstants(linearConstants1, linearConstants2) {\n  return linearConstants1.every(function (v, i) {\n    return tinyThrottle(v - linearConstants2[i]) === 0;\n  });\n}\nfunction isSamePoint(point1, point2) {\n  return !tinyThrottle(point1[0] - point2[0]) && !tinyThrottle(point1[1] - point2[1]);\n}\nfunction flat(arr) {\n  return arr.reduce(function (prev, current) {\n    prev.push.apply(prev, current);\n    return prev;\n  }, []);\n}\n\n/**\n * @namespace OverlapArea\n */\n\n/**\n * Gets the size of a shape (polygon) made of points.\n * @memberof OverlapArea\n */\n\nfunction getAreaSize(points) {\n  if (points.length < 3) {\n    return 0;\n  }\n  return Math.abs(sum(points.map(function (point, i) {\n    var nextPoint = points[i + 1] || points[0];\n    return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n  }))) / 2;\n}\n/**\n * Get points that fit the rect,\n * @memberof OverlapArea\n */\n\nfunction fitPoints(points, rect) {\n  var width = rect.width,\n    height = rect.height,\n    left = rect.left,\n    top = rect.top;\n  var _a = getMinMaxs(points),\n    minX = _a.minX,\n    minY = _a.minY,\n    maxX = _a.maxX,\n    maxY = _a.maxY;\n  var ratioX = width / (maxX - minX);\n  var ratioY = height / (maxY - minY);\n  return points.map(function (point) {\n    return [left + (point[0] - minX) * ratioX, top + (point[1] - minY) * ratioY];\n  });\n}\n/**\n * Get the minimum and maximum points of the points.\n * @memberof OverlapArea\n */\n\nfunction getMinMaxs(points) {\n  var xs = points.map(function (point) {\n    return point[0];\n  });\n  var ys = points.map(function (point) {\n    return point[1];\n  });\n  return {\n    minX: Math.min.apply(Math, xs),\n    minY: Math.min.apply(Math, ys),\n    maxX: Math.max.apply(Math, xs),\n    maxY: Math.max.apply(Math, ys)\n  };\n}\n/**\n * Whether the point is in shape\n * @param - point pos\n * @param - shape points\n * @param - whether to check except line\n * @memberof OverlapArea\n */\n\nfunction isInside(pos, points, excludeLine) {\n  var x = pos[0],\n    y = pos[1];\n  var _a = getMinMaxs(points),\n    minX = _a.minX,\n    maxX = _a.maxX;\n  var xLine = [[minX, y], [maxX, y]];\n  var xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n  var lines = convertLines(points);\n  var intersectionPosInfos = [];\n  lines.forEach(function (line) {\n    var linearConstants = getLinearConstants(line[0], line[1]);\n    var standardPoint = line[0];\n    if (isSameConstants(xLinearConstants, linearConstants)) {\n      intersectionPosInfos.push({\n        pos: pos,\n        line: line,\n        type: \"line\"\n      });\n    } else {\n      var xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);\n      xPoints.forEach(function (point) {\n        if (line.some(function (linePoint) {\n          return isSamePoint(linePoint, point);\n        })) {\n          intersectionPosInfos.push({\n            pos: point,\n            line: line,\n            type: \"point\"\n          });\n        } else if (tinyThrottle(standardPoint[1] - y) !== 0) {\n          intersectionPosInfos.push({\n            pos: point,\n            line: line,\n            type: \"intersection\"\n          });\n        }\n      });\n    }\n  });\n  if (!excludeLine) {\n    // on line\n    if (find(intersectionPosInfos, function (p) {\n      return p[0] === x;\n    })) {\n      return true;\n    }\n  }\n  var intersectionCount = 0;\n  var xMap = {};\n  intersectionPosInfos.forEach(function (_a) {\n    var pos = _a.pos,\n      type = _a.type,\n      line = _a.line;\n    if (pos[0] > x) {\n      return;\n    }\n    if (type === \"intersection\") {\n      ++intersectionCount;\n    } else if (type === \"line\") {\n      return;\n    } else if (type === \"point\") {\n      var point = find(line, function (linePoint) {\n        return linePoint[1] !== y;\n      });\n      var prevValue = xMap[pos[0]];\n      var nextValue = point[1] > y ? 1 : -1;\n      if (!prevValue) {\n        xMap[pos[0]] = nextValue;\n      } else if (prevValue !== nextValue) {\n        ++intersectionCount;\n      }\n    }\n  });\n  return intersectionCount % 2 === 1;\n}\n/**\n * Get distance from point to constants. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\n\nfunction getDistanceFromPointToConstants(_a, pos) {\n  var a = _a[0],\n    b = _a[1],\n    c = _a[2];\n  return (a * pos[0] + b * pos[1] + c) / (a * a + b * b);\n}\n/**\n * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\n\nfunction getLinearConstants(point1, point2) {\n  var x1 = point1[0],\n    y1 = point1[1];\n  var x2 = point2[0],\n    y2 = point2[1]; // ax + by + c = 0\n  // [a, b, c]\n\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  } // b > 0\n  // ax + by + c = 0\n\n  var a = 0;\n  var b = 0;\n  var c = 0;\n  if (!dx) {\n    if (dy) {\n      // -x + 1 = 0\n      a = -1;\n      c = x1;\n    }\n  } else if (!dy) {\n    // y - 1 = 0\n    b = 1;\n    c = -y1;\n  } else {\n    // y = -a(x - x1) + y1\n    // ax + y + a * x1 - y1 = 0\n    a = -dy / dx;\n    b = 1;\n    c = -a * x1 - y1;\n  }\n  return [a, b, c];\n}\n/**\n * Get intersection points with linear functions.\n * @memberof OverlapArea\n */\n\nfunction getIntersectionPointsByConstants(linearConstants1, linearConstants2) {\n  var a1 = linearConstants1[0],\n    b1 = linearConstants1[1],\n    c1 = linearConstants1[2];\n  var a2 = linearConstants2[0],\n    b2 = linearConstants2[1],\n    c2 = linearConstants2[2];\n  var isZeroA = a1 === 0 && a2 === 0;\n  var isZeroB = b1 === 0 && b2 === 0;\n  var results = [];\n  if (isZeroA && isZeroB) {\n    return [];\n  } else if (isZeroA) {\n    // b1 * y + c1 = 0\n    // b2 * y + c2 = 0\n    var y1 = -c1 / b1;\n    var y2 = -c2 / b2;\n    if (y1 !== y2) {\n      return [];\n    } else {\n      return [[-Infinity, y1], [Infinity, y1]];\n    }\n  } else if (isZeroB) {\n    // a1 * x + c1 = 0\n    // a2 * x + c2 = 0\n    var x1 = -c1 / a1;\n    var x2 = -c2 / a2;\n    if (x1 !== x2) {\n      return [];\n    } else {\n      return [[x1, -Infinity], [x1, Infinity]];\n    }\n  } else if (a1 === 0) {\n    // b1 * y + c1 = 0\n    // y = - c1 / b1;\n    // a2 * x + b2 * y + c2 = 0\n    var y = -c1 / b1;\n    var x = -(b2 * y + c2) / a2;\n    results = [[x, y]];\n  } else if (a2 === 0) {\n    // b2 * y + c2 = 0\n    // y = - c2 / b2;\n    // a1 * x + b1 * y + c1 = 0\n    var y = -c2 / b2;\n    var x = -(b1 * y + c1) / a1;\n    results = [[x, y]];\n  } else if (b1 === 0) {\n    // a1 * x + c1 = 0\n    // x = - c1 / a1;\n    // a2 * x + b2 * y + c2 = 0\n    var x = -c1 / a1;\n    var y = -(a2 * x + c2) / b2;\n    results = [[x, y]];\n  } else if (b2 === 0) {\n    // a2 * x + c2 = 0\n    // x = - c2 / a2;\n    // a1 * x + b1 * y + c1 = 0\n    var x = -c2 / a2;\n    var y = -(a1 * x + c1) / b1;\n    results = [[x, y]];\n  } else {\n    // a1 * x + b1 * y + c1 = 0\n    // a2 * x + b2 * y + c2 = 0\n    // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0\n    // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0\n    // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)\n    var x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n    var y = -(a1 * x + c1) / b1;\n    results = [[x, y]];\n  }\n  return results.map(function (result) {\n    return [result[0], result[1]];\n  });\n}\n/**\n * Get intersection points to the two lines.\n * @memberof OverlapArea\n */\n\nfunction getIntersectionPoints(line1, line2, isLimit) {\n  var points = getIntersectionPointsByConstants(getLinearConstants(line1[0], line1[1]), getLinearConstants(line2[0], line2[1]));\n  if (isLimit) {\n    return getPointsOnLines(points, [line1, line2]);\n  }\n  return points;\n}\nfunction isPointOnLine(pos, line) {\n  var linearConstants = getLinearConstants(line[0], line[1]);\n  return tinyThrottle(getDistanceFromPointToConstants(linearConstants, pos)) === 0;\n}\n/**\n * Get the points on the lines (between two points).\n * @memberof OverlapArea\n */\n\nfunction getPointsOnLines(points, lines) {\n  var minMaxs = lines.map(function (line) {\n    return [0, 1].map(function (order) {\n      return [Math.min(line[0][order], line[1][order]), Math.max(line[0][order], line[1][order])];\n    });\n  });\n  var results = [];\n  if (points.length === 2) {\n    var _a = points[0],\n      x = _a[0],\n      y = _a[1];\n    if (!tinyThrottle(x - points[1][0])) {\n      /// Math.max(minY1, minY2)\n      var top = Math.max.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[1][0];\n      })); /// Math.min(maxY1, miax2)\n\n      var bottom = Math.min.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[1][1];\n      }));\n      if (tinyThrottle(top - bottom) > 0) {\n        return [];\n      }\n      results = [[x, top], [x, bottom]];\n    } else if (!tinyThrottle(y - points[1][1])) {\n      /// Math.max(minY1, minY2)\n      var left = Math.max.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[0][0];\n      })); /// Math.min(maxY1, miax2)\n\n      var right = Math.min.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[0][1];\n      }));\n      if (tinyThrottle(left - right) > 0) {\n        return [];\n      }\n      results = [[left, y], [right, y]];\n    }\n  }\n  if (!results.length) {\n    results = points.filter(function (point) {\n      var pointX = point[0],\n        pointY = point[1];\n      return minMaxs.every(function (minMax) {\n        return 0 <= tinyThrottle(pointX - minMax[0][0]) && 0 <= tinyThrottle(minMax[0][1] - pointX) && 0 <= tinyThrottle(pointY - minMax[1][0]) && 0 <= tinyThrottle(minMax[1][1] - pointY);\n      });\n    });\n  }\n  return results.map(function (result) {\n    return [tinyThrottle(result[0]), tinyThrottle(result[1])];\n  });\n}\n/**\n* Convert two points into lines.\n* @function\n* @memberof OverlapArea\n*/\n\nfunction convertLines(points) {\n  return __spreadArrays(points.slice(1), [points[0]]).map(function (point, i) {\n    return [points[i], point];\n  });\n}\nfunction getOverlapPointInfos(points1, points2) {\n  var targetPoints1 = points1.slice();\n  var targetPoints2 = points2.slice();\n  if (getShapeDirection(targetPoints1) === -1) {\n    targetPoints1.reverse();\n  }\n  if (getShapeDirection(targetPoints2) === -1) {\n    targetPoints2.reverse();\n  }\n  var lines1 = convertLines(targetPoints1);\n  var lines2 = convertLines(targetPoints2);\n  var linearConstantsList1 = lines1.map(function (line1) {\n    return getLinearConstants(line1[0], line1[1]);\n  });\n  var linearConstantsList2 = lines2.map(function (line2) {\n    return getLinearConstants(line2[0], line2[1]);\n  });\n  var overlapInfos = [];\n  linearConstantsList1.forEach(function (linearConstants1, i) {\n    var line1 = lines1[i];\n    var linePointInfos = [];\n    linearConstantsList2.forEach(function (linearConstants2, j) {\n      var intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);\n      var points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);\n      linePointInfos.push.apply(linePointInfos, points.map(function (pos) {\n        return {\n          index1: i,\n          index2: j,\n          pos: pos,\n          type: \"intersection\"\n        };\n      }));\n    });\n    linePointInfos.sort(function (a, b) {\n      return getDist(line1[0], a.pos) - getDist(line1[0], b.pos);\n    });\n    overlapInfos.push.apply(overlapInfos, linePointInfos);\n    if (isInside(line1[1], targetPoints2)) {\n      overlapInfos.push({\n        index1: i,\n        index2: -1,\n        pos: line1[1],\n        type: \"inside\"\n      });\n    }\n  });\n  lines2.forEach(function (line2, i) {\n    if (!isInside(line2[1], targetPoints1)) {\n      return;\n    }\n    var isNext = false;\n    var index = findIndex(overlapInfos, function (_a) {\n      var index2 = _a.index2;\n      if (index2 === i) {\n        isNext = true;\n        return false;\n      }\n      if (isNext) {\n        return true;\n      }\n      return false;\n    });\n    if (index === -1) {\n      isNext = false;\n      index = findIndex(overlapInfos, function (_a) {\n        var index1 = _a.index1,\n          index2 = _a.index2;\n        if (index1 === -1 && index2 + 1 === i) {\n          isNext = true;\n          return false;\n        }\n        if (isNext) {\n          return true;\n        }\n        return false;\n      });\n    }\n    if (index === -1) {\n      overlapInfos.push({\n        index1: -1,\n        index2: i,\n        pos: line2[1],\n        type: \"inside\"\n      });\n    } else {\n      overlapInfos.splice(index, 0, {\n        index1: -1,\n        index2: i,\n        pos: line2[1],\n        type: \"inside\"\n      });\n    }\n  });\n  var pointMap = {};\n  return overlapInfos.filter(function (_a) {\n    var pos = _a.pos;\n    var key = pos[0] + \"x\" + pos[1];\n    if (pointMap[key]) {\n      return false;\n    }\n    pointMap[key] = true;\n    return true;\n  });\n}\n/**\n* Get the points of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\n\nfunction getOverlapPoints(points1, points2) {\n  var infos = getOverlapPointInfos(points1, points2);\n  return infos.map(function (_a) {\n    var pos = _a.pos;\n    return pos;\n  });\n}\nfunction isConnectedLine(line) {\n  var _a = line[0],\n    prevIndex1 = _a.index1,\n    prevIndex2 = _a.index2,\n    _b = line[1],\n    nextIndex1 = _b.index1,\n    nextIndex2 = _b.index2;\n  if (prevIndex1 !== -1) {\n    // same line\n    if (prevIndex1 === nextIndex1) {\n      return true;\n    }\n    if (prevIndex1 + 1 === nextIndex1) {\n      return true;\n    }\n  }\n  if (prevIndex2 !== -1) {\n    // same line\n    if (prevIndex2 === nextIndex2) {\n      return true;\n    }\n    if (prevIndex2 + 1 === nextIndex2) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n* Get the areas of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\n\nfunction getOverlapAreas(points1, points2) {\n  var infos = getOverlapPointInfos(points1, points2);\n  var areas = [];\n  var area;\n  getOverlapPointInfos(points1, points2).forEach(function (info, i, arr) {\n    if (i === 0 || !isConnectedLine([arr[i - 1], info])) {\n      area = [info];\n      areas.push(area);\n    } else {\n      area.push(info);\n    }\n  });\n  return areas.map(function (area) {\n    return area.map(function (_a) {\n      var pos = _a.pos;\n      return pos;\n    });\n  });\n}\nfunction findReversedAreas(points1, points2, index, areas) {\n  if (index === void 0) {\n    index = 0;\n  }\n  if (areas === void 0) {\n    areas = [];\n  }\n  var isFirst = areas.length === 0;\n  var length = points1.length;\n  var nextIndex = points1[index] ? index : 0;\n  var nextPoints1 = __spreadArrays(points1.slice(nextIndex), points1.slice(0, nextIndex));\n  var _loop_1 = function (i) {\n    var point1 = nextPoints1[i];\n    if (find(points2, function (point2) {\n      return point2[0] === point1[0] && point2[1] === point1[1];\n    })) {\n      return \"continue\";\n    }\n    if (areas.some(function (nextArea) {\n      return find(nextArea, function (areaPoint) {\n        return areaPoint[0] === point1[0] && areaPoint[1] === point1[1];\n      });\n    })) {\n      if (isFirst) {\n        return \"continue\";\n      } else {\n        return \"break\";\n      }\n    }\n    var nextArea = void 0;\n    if (isFirst) {\n      nextArea = [];\n      areas.push(nextArea);\n    } else {\n      nextArea = areas[areas.length - 1];\n    }\n    nextArea.push(point1);\n    var line = [point1, points1[index + 1] || points1[0]];\n    var nextPoint2 = points2.filter(function (point2) {\n      return isPointOnLine(point2, line);\n    }).sort(function (a, b) {\n      return getDist(point1, a) - getDist(point1, b);\n    })[0];\n    if (!nextPoint2) {\n      findReversedAreas(nextPoints1, points2, i + 1, areas);\n      return \"break\";\n    } else {\n      var point2Index = points2.indexOf(nextPoint2);\n      findReversedAreas(points2, points1, point2Index, areas);\n      if (!isFirst) {\n        return \"break\";\n      }\n    }\n  };\n  for (var i = 0; i < length; ++i) {\n    var state_1 = _loop_1(i);\n    if (state_1 === \"break\") break;\n  }\n  return areas;\n}\nfunction findConnectedAreas(points1, points2) {\n  return findReversedAreas(points1, __spreadArrays(points2).reverse());\n}\n/**\n* Get non-overlapping areas of two shapes based on points1.\n* @memberof OverlapArea\n*/\n\nfunction getUnoverlapAreas(points1, points2) {\n  if (!points2.length) {\n    return [__spreadArrays(points1)];\n  }\n  var overlapAreas = getOverlapAreas(points1, points2);\n  var unoverlapAreas = [points1];\n  overlapAreas.forEach(function (overlapArea) {\n    var nextOverlapArea = __spreadArrays(overlapArea).reverse();\n    unoverlapAreas = flat(unoverlapAreas.map(function (area) {\n      var connectedAreas = findReversedAreas(area, nextOverlapArea);\n      var firstConnectedArea = connectedAreas[0];\n      if (connectedAreas.length === 1 && nextOverlapArea.every(function (point) {\n        return firstConnectedArea.indexOf(point) === -1;\n      })) {\n        var lastPoint_1 = firstConnectedArea[firstConnectedArea.length - 1];\n        var firstPoint = __spreadArrays(nextOverlapArea).sort(function (a, b) {\n          return getDist(lastPoint_1, a) - getDist(lastPoint_1, b);\n        })[0];\n        var firstIndex = nextOverlapArea.indexOf(firstPoint);\n        firstConnectedArea.push.apply(firstConnectedArea, __spreadArrays(nextOverlapArea.slice(firstIndex), nextOverlapArea.slice(0, firstIndex), [nextOverlapArea[firstIndex], lastPoint_1]));\n      }\n      return connectedAreas;\n    }));\n  });\n  return unoverlapAreas;\n}\n/**\n* Gets the size of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\n\nfunction getOverlapSize(points1, points2) {\n  var points = getOverlapPoints(points1, points2);\n  return getAreaSize(points);\n}\nexport { convertLines, findConnectedAreas, fitPoints, getAreaSize, getDistanceFromPointToConstants, getIntersectionPoints, getIntersectionPointsByConstants, getLinearConstants, getMinMaxs, getOverlapAreas, getOverlapPoints, getOverlapSize, getPointsOnLines, getUnoverlapAreas, isInside, isPointOnLine };","map":{"version":3,"mappings":"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","names":["tinyThrottle","num","throttle","TINY_NUM","isSameConstants","linearConstants1","linearConstants2","every","v","i","isSamePoint","point1","point2","flat","arr","reduce","prev","current","push","getAreaSize","points","length","Math","abs","sum","map","point","nextPoint","fitPoints","rect","height","left","top","getMinMaxs","minX","minY","maxX","maxY","ratioX","width","ratioY","xs","ys","min","max","isInside","pos","excludeLine","y","xLine","xLinearConstants","getLinearConstants","lines","convertLines","intersectionPosInfos","forEach","linearConstants","line","standardPoint","type","xPoints","getPointsOnLines","getIntersectionPointsByConstants","some","linePoint","find","x","intersectionCount","xMap","_a","prevValue","nextValue","getDistanceFromPointToConstants","a","b","c","y1","y2","dx","x2","x1","dy","b1","c1","b2","c2","isZeroA","a1","a2","isZeroB","results","Infinity","result","getIntersectionPoints","line1","line2","isLimit","isPointOnLine","minMaxs","order","bottom","right","filter","pointY","pointX","minMax","__spreadArrays","slice","getOverlapPointInfos","points1","points2","targetPoints1","targetPoints2","getShapeDirection","reverse","lines1","lines2","linearConstantsList1","linearConstantsList2","overlapInfos","linePointInfos","j","intersectionPoints","index1","index2","sort","getDist","isNext","index","findIndex","splice","pointMap","key","getOverlapPoints","infos","isConnectedLine","prevIndex1","prevIndex2","_b","nextIndex1","nextIndex2","getOverlapAreas","areas","area","info","findReversedAreas","isFirst","nextIndex","nextPoints1","nextArea","areaPoint","nextPoint2","point2Index","indexOf","findConnectedAreas","getUnoverlapAreas","overlapAreas","unoverlapAreas","nextOverlapArea","overlapArea","connectedAreas","firstConnectedArea","lastPoint_1","firstPoint","firstIndex","getOverlapSize"],"sources":["C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\overlap-area\\src\\utils.ts","C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\overlap-area\\src\\index.ts"],"sourcesContent":["import { throttle, TINY_NUM } from \"@daybrush/utils\";\n\nexport function tinyThrottle(num: number) {\n    return throttle(num, TINY_NUM);\n}\n\nexport function isSameConstants(\n    linearConstants1: number[],\n    linearConstants2: number[],\n) {\n    return linearConstants1.every((v, i) => tinyThrottle(v - linearConstants2[i]) === 0);\n}\n\nexport function isSamePoint(\n    point1: number[],\n    point2: number[],\n) {\n    return !tinyThrottle(point1[0] - point2[0]) && !tinyThrottle(point1[1] - point2[1]);\n}\n\nexport function flat<Type extends any>(arr: Type[][]): Type[] {\n    return arr.reduce<Type[]>((prev, current) => {\n        prev.push(...current);\n        return prev;\n    }, []);\n}\n","import { sum, findIndex, getShapeDirection, getDist, throttle, TINY_NUM, find } from \"@daybrush/utils\";\nimport { OverlapPointInfo, PointInfo, Rect } from \"./types\";\nimport { flat, isSameConstants, isSamePoint, tinyThrottle } from \"./utils\";\n\n/**\n * @namespace OverlapArea\n */\n\n/**\n * Gets the size of a shape (polygon) made of points.\n * @memberof OverlapArea\n */\nexport function getAreaSize(points: number[][]): number {\n    if (points.length < 3) {\n        return 0;\n    }\n    return Math.abs(sum(points.map((point, i) => {\n        const nextPoint = points[i + 1] || points[0];\n\n        return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n    }))) / 2;\n}\n\n\n/**\n * Get points that fit the rect,\n * @memberof OverlapArea\n */\nexport function fitPoints(points: number[][], rect: Rect): number[][] {\n    const { width, height, left, top } = rect;\n    const { minX, minY, maxX, maxY } = getMinMaxs(points);\n    const ratioX = width / (maxX - minX);\n    const ratioY = height / (maxY - minY);\n\n    return points.map(point => {\n        return [\n            left + (point[0] - minX) * ratioX,\n            top + (point[1] - minY) * ratioY,\n        ];\n    });\n}\n/**\n * Get the minimum and maximum points of the points.\n * @memberof OverlapArea\n */\nexport function getMinMaxs(points: number[][]): { minX: number, minY: number, maxX: number, maxY: number } {\n    const xs = points.map(point => point[0]);\n    const ys = points.map(point => point[1]);\n\n    return {\n        minX: Math.min(...xs),\n        minY: Math.min(...ys),\n        maxX: Math.max(...xs),\n        maxY: Math.max(...ys),\n    };\n}\n/**\n * Whether the point is in shape\n * @param - point pos\n * @param - shape points\n * @param - whether to check except line\n * @memberof OverlapArea\n */\nexport function isInside(pos: number[], points: number[][], excludeLine?: boolean): boolean {\n    const [x, y] = pos;\n    const {\n        minX,\n        maxX,\n    } = getMinMaxs(points);\n\n    const xLine = [[minX, y], [maxX, y]];\n    const xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n    const lines = convertLines(points);\n\n    interface IntersectionPosInfo {\n        pos: number[];\n        line: number[][];\n        type: \"intersection\" | \"point\" | \"line\";\n    }\n    const intersectionPosInfos: IntersectionPosInfo[] = [];\n\n    lines.forEach(line => {\n        const linearConstants = getLinearConstants(line[0], line[1]);\n        const standardPoint = line[0];\n\n        if (isSameConstants(xLinearConstants, linearConstants)) {\n            intersectionPosInfos.push({\n                pos: pos,\n                line,\n                type: \"line\",\n            });\n        } else {\n            const xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);\n\n            xPoints.forEach(point => {\n                if (line.some(linePoint => isSamePoint(linePoint, point))) {\n                    intersectionPosInfos.push({\n                        pos: point,\n                        line,\n                        type: \"point\",\n                    });\n                } else if (tinyThrottle(standardPoint[1] - y) !== 0) {\n                    intersectionPosInfos.push({\n                        pos: point,\n                        line,\n                        type: \"intersection\",\n                    });\n                }\n            })\n        }\n    });\n\n    if (!excludeLine) {\n        // on line\n        if (find(intersectionPosInfos, p => p[0] === x)) {\n            return true;\n        }\n    }\n    let intersectionCount = 0;\n    const xMap = {};\n\n    intersectionPosInfos.forEach(({ pos, type, line }) => {\n        if (pos[0] > x) {\n            return;\n        }\n        if (type === \"intersection\") {\n            ++intersectionCount;\n        } else if (type === \"line\") {\n            return;\n        } else if (type === \"point\") {\n            const point = find(line, linePoint => linePoint[1] !== y);\n            const prevValue = xMap[pos[0]];\n            const nextValue = point[1] > y ? 1 : -1;\n\n            if (!prevValue) {\n                xMap[pos[0]] = nextValue;\n            } else if (prevValue !== nextValue) {\n                ++intersectionCount;\n            }\n        }\n    });\n    return intersectionCount % 2 === 1;\n}\n/**\n * Get distance from point to constants. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\nexport function getDistanceFromPointToConstants(\n    [a, b, c]: [number, number, number],\n    pos: number[],\n) {\n    return (a * pos[0] + b * pos[1] + c) / (a * a + b * b);\n}\n\n/**\n * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\nexport function getLinearConstants(point1: number[], point2: number[]): [number, number, number] {\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n    // ax + by + c = 0\n    // [a, b, c]\n    let dx = x2 - x1;\n    let dy = y2 - y1;\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n\n    // b > 0\n    // ax + by + c = 0\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    if (!dx) {\n        if (dy) {\n            // -x + 1 = 0\n            a = -1;\n            c = x1;\n        }\n    } else if (!dy) {\n        // y - 1 = 0\n        b = 1;\n        c = -y1;\n    } else {\n        // y = -a(x - x1) + y1\n        // ax + y + a * x1 - y1 = 0\n        a = -dy / dx;\n        b = 1;\n        c = -a * x1 - y1;\n    }\n\n    return [a, b, c] as [number, number, number];\n}\n/**\n * Get intersection points with linear functions.\n * @memberof OverlapArea\n */\nexport function getIntersectionPointsByConstants(\n    linearConstants1: number[],\n    linearConstants2: number[],\n): number[][] {\n    const [a1, b1, c1] = linearConstants1;\n    const [a2, b2, c2] = linearConstants2;\n\n    const isZeroA = a1 === 0 && a2 === 0;\n    const isZeroB = b1 === 0 && b2 === 0;\n    let results: number[][] = [];\n\n    if (isZeroA && isZeroB) {\n        return [];\n    } else if (isZeroA) {\n        // b1 * y + c1 = 0\n        // b2 * y + c2 = 0\n        const y1 = -c1 / b1;\n        const y2 = -c2 / b2;\n\n        if (y1 !== y2) {\n            return [];\n        } else {\n            return [\n                [-Infinity, y1],\n                [Infinity, y1],\n            ];\n        }\n    } else if (isZeroB) {\n        // a1 * x + c1 = 0\n        // a2 * x + c2 = 0\n        const x1 = -c1 / a1;\n        const x2 = -c2 / a2;\n\n        if (x1 !== x2) {\n            return [];\n        } else {\n            return [\n                [x1, -Infinity],\n                [x1, Infinity],\n            ];\n        }\n    } else if (a1 === 0) {\n        // b1 * y + c1 = 0\n        // y = - c1 / b1;\n        // a2 * x + b2 * y + c2 = 0\n        const y = -c1 / b1;\n        const x = -(b2 * y + c2) / a2;\n\n        results = [[x, y]];\n    } else if (a2 === 0) {\n        // b2 * y + c2 = 0\n        // y = - c2 / b2;\n        // a1 * x + b1 * y + c1 = 0\n        const y = -c2 / b2;\n        const x = -(b1 * y + c1) / a1;\n\n        results = [[x, y]];\n    } else if (b1 === 0) {\n        // a1 * x + c1 = 0\n        // x = - c1 / a1;\n        // a2 * x + b2 * y + c2 = 0\n        const x = - c1 / a1;\n        const y = -(a2 * x + c2) / b2;\n\n        results = [[x, y]];\n    } else if (b2 === 0) {\n        // a2 * x + c2 = 0\n        // x = - c2 / a2;\n        // a1 * x + b1 * y + c1 = 0\n        const x = - c2 / a2;\n        const y = -(a1 * x + c1) / b1;\n\n        results = [[x, y]];\n    } else {\n        // a1 * x + b1 * y + c1 = 0\n        // a2 * x + b2 * y + c2 = 0\n        // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0\n        // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0\n        // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)\n        const x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n        const y = -(a1 * x + c1) / b1;\n\n        results = [[x, y]];\n    }\n\n    return results.map(result => [result[0], result[1]]);\n}\n/**\n * Get intersection points to the two lines.\n * @memberof OverlapArea\n */\nexport function getIntersectionPoints(\n    line1: number[][],\n    line2: number[][],\n    isLimit?: boolean,\n): number[][] {\n    const points = getIntersectionPointsByConstants(\n        getLinearConstants(line1[0], line1[1]),\n        getLinearConstants(line2[0], line2[1]),\n    );\n\n    if (isLimit) {\n        return getPointsOnLines(points, [line1, line2]);\n    }\n    return points;\n}\n\nexport function isPointOnLine(\n    pos: number[],\n    line: number[][],\n) {\n    const linearConstants = getLinearConstants(line[0], line[1]);\n\n    return tinyThrottle(getDistanceFromPointToConstants(linearConstants, pos)) === 0;\n}\n\n/**\n * Get the points on the lines (between two points).\n * @memberof OverlapArea\n */\nexport function getPointsOnLines(\n    points: number[][],\n    lines: number[][][],\n): number[][] {\n    const minMaxs = lines.map(line => [0, 1].map(order => [\n        Math.min(line[0][order], line[1][order]),\n        Math.max(line[0][order], line[1][order]),\n    ]));\n    let results: number[][] = [];\n\n    if (points.length === 2) {\n        const [x, y] = points[0];\n        if (!tinyThrottle(x - points[1][0])) {\n            /// Math.max(minY1, minY2)\n            const top = Math.max(...minMaxs.map(minMax => minMax[1][0]));\n            /// Math.min(maxY1, miax2)\n            const bottom = Math.min(...minMaxs.map(minMax => minMax[1][1]));\n\n            if (tinyThrottle(top - bottom) > 0) {\n                return [];\n            }\n            results = [\n                [x, top],\n                [x, bottom],\n            ];\n        } else if (!tinyThrottle(y - points[1][1])) {\n            /// Math.max(minY1, minY2)\n            const left = Math.max(...minMaxs.map(minMax => minMax[0][0]));\n            /// Math.min(maxY1, miax2)\n            const right = Math.min(...minMaxs.map(minMax => minMax[0][1]));\n\n            if (tinyThrottle(left - right) > 0) {\n                return [];\n            }\n            results = [\n                [left, y],\n                [right, y],\n            ];\n        }\n    }\n\n    if (!results.length) {\n        results = points.filter(point => {\n            const [pointX, pointY] = point;\n\n            return minMaxs.every(minMax => {\n                return (0 <= tinyThrottle(pointX - minMax[0][0]) && 0 <= tinyThrottle(minMax[0][1] - pointX))\n                && (0 <= tinyThrottle(pointY - minMax[1][0]) && 0 <= tinyThrottle(minMax[1][1] - pointY));\n            });\n        });\n    }\n\n    return results.map(result => [tinyThrottle(result[0]), tinyThrottle(result[1])]);\n\n}\n/**\n* Convert two points into lines.\n* @function\n* @memberof OverlapArea\n*/\nexport function convertLines(points: number[][]): number[][][] {\n    return [...points.slice(1), points[0]].map((point, i) => [points[i], point]);\n}\n\nfunction getOverlapPointInfos(points1: number[][], points2: number[][]): OverlapPointInfo[] {\n    const targetPoints1 = points1.slice();\n    const targetPoints2 = points2.slice();\n\n    if (getShapeDirection(targetPoints1) === -1) {\n        targetPoints1.reverse();\n    }\n    if (getShapeDirection(targetPoints2) === -1) {\n        targetPoints2.reverse();\n    }\n    const lines1 = convertLines(targetPoints1);\n    const lines2 = convertLines(targetPoints2);\n    const linearConstantsList1 = lines1.map(line1 => getLinearConstants(line1[0], line1[1]));\n    const linearConstantsList2 = lines2.map(line2 => getLinearConstants(line2[0], line2[1]));\n\n    const overlapInfos: OverlapPointInfo[] = [];\n\n    linearConstantsList1.forEach((linearConstants1, i) => {\n        const line1 = lines1[i];\n        const linePointInfos: OverlapPointInfo[] = [];\n        linearConstantsList2.forEach((linearConstants2, j) => {\n            const intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);\n            const points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);\n\n            linePointInfos.push(...points.map(pos => ({\n                index1: i,\n                index2: j,\n                pos,\n                type: \"intersection\" as const,\n            })));\n        });\n        linePointInfos.sort((a, b) => {\n            return getDist(line1[0], a.pos) - getDist(line1[0], b.pos);\n        });\n\n        overlapInfos.push(...linePointInfos);\n\n        if (isInside(line1[1], targetPoints2)) {\n            overlapInfos.push({\n                index1: i,\n                index2: -1,\n                pos: line1[1],\n                type: \"inside\" as const,\n            });\n        }\n    });\n\n    lines2.forEach((line2, i) => {\n        if (!isInside(line2[1], targetPoints1)) {\n            return;\n        }\n        let isNext = false;\n        let index = findIndex(overlapInfos, ({ index2 }) => {\n            if (index2 === i) {\n                isNext = true;\n                return false;\n            }\n\n            if (isNext) {\n                return true;\n            }\n            return false;\n        });\n        if (index === -1) {\n            isNext = false;\n            index = findIndex(overlapInfos, ({ index1, index2 }) => {\n                if (index1 === -1 && index2 + 1 === i) {\n                    isNext = true;\n                    return false;\n                }\n\n                if (isNext) {\n                    return true;\n                }\n                return false;\n            });\n        }\n        if (index === -1) {\n            overlapInfos.push({\n                index1: -1,\n                index2: i,\n                pos: line2[1],\n                type: \"inside\" as const,\n            });\n        } else {\n            overlapInfos.splice(index, 0, {\n                index1: -1,\n                index2: i,\n                pos: line2[1],\n                type: \"inside\" as const,\n            });\n\n        }\n    });\n    const pointMap: Record<string, boolean> = {};\n\n    return overlapInfos.filter(({ pos }) => {\n        const key = `${pos[0]}x${pos[1]}`;\n\n        if (pointMap[key]) {\n            return false;\n        }\n        pointMap[key] = true;\n        return true;\n    });\n}\n\n/**\n* Get the points of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapPoints(points1: number[][], points2: number[][]): number[][] {\n    const infos = getOverlapPointInfos(points1, points2);\n\n    return infos.map(({ pos }) => pos);\n}\n\nfunction isConnectedLine(line: OverlapPointInfo[]) {\n    const {\n        0: {\n            index1: prevIndex1,\n            index2: prevIndex2,\n        },\n        1: {\n            index1: nextIndex1,\n            index2: nextIndex2,\n        }\n    } = line;\n\n    if (prevIndex1 !== -1) {\n        // same line\n        if (prevIndex1 === nextIndex1) {\n            return true;\n        }\n        if (prevIndex1 + 1 === nextIndex1) {\n            return true;\n        }\n    }\n    if (prevIndex2 !== -1) {\n        // same line\n        if (prevIndex2 === nextIndex2) {\n            return true;\n        }\n        if (prevIndex2 + 1 === nextIndex2) {\n            return true;\n        }\n    }\n\n    return false;\n\n}\n/**\n* Get the areas of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapAreas(points1: number[][], points2: number[][]): number[][][] {\n    const infos = getOverlapPointInfos(points1, points2);\n    const areas: OverlapPointInfo[][] = [];\n    let area: OverlapPointInfo[];\n\n    getOverlapPointInfos(points1, points2).forEach((info, i, arr) => {\n        if (i === 0 || !isConnectedLine([arr[i - 1], info])) {\n            area = [info];\n            areas.push(area);\n        } else {\n            area.push(info);\n        }\n    });\n\n    return areas.map(area => area.map(({ pos }) => pos));\n}\nfunction findReversedAreas(points1: number[][], points2: number[][], index: number = 0, areas: number[][][] = []): number[][][] {\n    const isFirst = areas.length === 0;\n    const length = points1.length;\n    const nextIndex = points1[index] ? index : 0;\n    const nextPoints1 = [...points1.slice(nextIndex), ...points1.slice(0, nextIndex)];\n\n    for (let i = 0; i < length; ++i) {\n        const point1 = nextPoints1[i];\n\n        if (find(points2, point2 => point2[0] === point1[0] && point2[1] === point1[1])) {\n            continue;\n        }\n        if (areas.some(nextArea => find(nextArea, areaPoint => areaPoint[0] === point1[0] && areaPoint[1] === point1[1]))) {\n            if (isFirst) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        let nextArea: number[][];\n\n        if (isFirst) {\n            nextArea = [];\n            areas.push(nextArea);\n        } else {\n            nextArea = areas[areas.length - 1];\n        }\n        nextArea.push(point1);\n\n\n        const line = [point1, points1[index + 1] || points1[0]];\n        const nextPoint2 = points2.filter(point2 => {\n            return isPointOnLine(point2, line);\n        }).sort((a, b) => {\n            return getDist(point1, a) - getDist(point1, b);\n        })[0];\n\n        if (!nextPoint2) {\n            findReversedAreas(nextPoints1, points2, i + 1, areas);\n            break;\n        } else {\n            const point2Index = points2.indexOf(nextPoint2);\n\n            findReversedAreas(points2, points1, point2Index, areas);\n            if (!isFirst) {\n                break;\n            }\n        }\n    }\n    return areas;\n}\nexport function findConnectedAreas(points1: number[][], points2: number[][]) {\n    return findReversedAreas(points1, [...points2].reverse());\n}\n/**\n* Get non-overlapping areas of two shapes based on points1.\n* @memberof OverlapArea\n*/\nexport function getUnoverlapAreas(points1: number[][], points2: number[][]): number[][][] {\n    if (!points2.length) {\n        return [[...points1]];\n    }\n    const overlapAreas = getOverlapAreas(points1, points2);\n     let unoverlapAreas = [points1];\n\n    overlapAreas.forEach(overlapArea => {\n        const nextOverlapArea = [...overlapArea].reverse();\n\n        unoverlapAreas = flat(unoverlapAreas.map(area => {\n            const connectedAreas = findReversedAreas(area, nextOverlapArea);\n            const firstConnectedArea = connectedAreas[0];\n\n            if (connectedAreas.length === 1 && nextOverlapArea.every(point => firstConnectedArea.indexOf(point) === -1)) {\n                const lastPoint = firstConnectedArea[firstConnectedArea.length - 1];\n                const firstPoint = [...nextOverlapArea].sort((a, b) => {\n                    return getDist(lastPoint, a) - getDist(lastPoint, b);\n                })[0];\n                const firstIndex = nextOverlapArea.indexOf(firstPoint);\n\n                firstConnectedArea.push(\n                    ...nextOverlapArea.slice(firstIndex),\n                    ...nextOverlapArea.slice(0, firstIndex),\n                    nextOverlapArea[firstIndex],\n                    lastPoint,\n                );\n            }\n            return connectedAreas;\n        }));\n    });\n\n    return unoverlapAreas;\n}\n/**\n* Gets the size of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapSize(points1: number[][], points2: number[][]): number {\n    const points = getOverlapPoints(points1, points2);\n\n    return getAreaSize(points);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}