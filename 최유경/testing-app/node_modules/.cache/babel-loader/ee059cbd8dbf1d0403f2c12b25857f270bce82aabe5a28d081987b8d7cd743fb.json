{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: order-map\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/order-map.git\nversion: 0.2.2\n*/\n/**\n *\n */\nvar OrderMap = /*#__PURE__*/\nfunction () {\n  /**\n   *\n   */\n  function OrderMap(separator) {\n    this.separator = separator;\n    this.orderMap = {};\n  }\n  /**\n   *\n   */\n\n  var __proto = OrderMap.prototype;\n  __proto.getFullName = function (names) {\n    return names.join(this.separator);\n  };\n  /**\n   *\n   */\n\n  __proto.get = function (names) {\n    return this.orderMap[this.getFullName(names)];\n  };\n  /**\n   *\n   */\n\n  __proto.gets = function (names, isFull) {\n    if (isFull === void 0) {\n      isFull = true;\n    }\n    var fullOrders = [];\n    var self = this;\n    function pushOrders(nextNames, stack) {\n      var orders = self.get(nextNames);\n      if (!orders) {\n        return;\n      }\n      orders.forEach(function (name) {\n        var nextStack = stack.concat([name]);\n        var nextOrders = pushOrders(nextNames.concat([name]), nextStack);\n        if (!nextOrders || !nextOrders.length) {\n          fullOrders.push(stack.concat([name]));\n        }\n      });\n      return orders;\n    }\n    pushOrders(names, isFull ? names : []);\n    return fullOrders;\n  };\n  /**\n   *\n   */\n\n  __proto.set = function (names, orders) {\n    var _this = this;\n    names.forEach(function (name, i) {\n      _this.addName(names.slice(0, i), name);\n    });\n    this.orderMap[this.getFullName(names)] = orders;\n    return orders;\n  };\n  /**\n   *\n   */\n\n  __proto.add = function (names) {\n    var length = names.length;\n    if (!length) {\n      return [];\n    }\n    return this.addName(names.slice(0, -1), names[length - 1]);\n  };\n  /**\n   *\n   */\n\n  __proto.addName = function (names, name) {\n    var orders = this.get(names) || this.set(names, []);\n    if (orders.indexOf(name) === -1) {\n      orders.push(name);\n    }\n    return orders;\n  };\n  /**\n   *\n   */\n\n  __proto.findIndex = function (names, orderName) {\n    var orders = this.orderMap[this.getFullName(names)];\n    if (!orders) {\n      return -1;\n    }\n    return orders.indexOf(orderName);\n  };\n  /**\n   *\n   */\n\n  __proto.remove = function (names) {\n    var fullName = this.getFullName(names);\n    var orderMap = this.orderMap;\n    for (var name in orderMap) {\n      if (name.indexOf(fullName) === 0) {\n        delete orderMap[name];\n      }\n    }\n    var length = names.length;\n    if (length) {\n      var prevNames = names.slice(0, -1);\n      var lastName = names[length - 1];\n      this.splice(prevNames, this.findIndex(prevNames, lastName), 1);\n    }\n    return this;\n  };\n  /**\n   *\n   */\n\n  __proto.filter = function (names, callback, isFull) {\n    if (isFull === void 0) {\n      isFull = true;\n    }\n    var result = this.gets(names, isFull).filter(callback);\n    var map = new OrderMap(this.separator);\n    var stack = isFull ? [] : names;\n    result.forEach(function (nextNames) {\n      map.add(stack.concat(nextNames));\n    });\n    return map;\n  };\n  /**\n   *\n   */\n\n  __proto.splice = function (names, index, deleteCount) {\n    var orders = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      orders[_i - 3] = arguments[_i];\n    }\n    var currentOrders = this.get(names) || this.set(names, []);\n    currentOrders.splice.apply(currentOrders, [index, deleteCount].concat(orders));\n    return this;\n  };\n  /**\n   *\n   */\n\n  __proto.clear = function () {\n    this.orderMap = {};\n  };\n  /**\n   *\n   */\n\n  __proto.setObject = function (obj) {\n    var orderMap = this.orderMap;\n    for (var name in obj) {\n      orderMap[name] = obj[name].slice();\n    }\n  };\n  /**\n   *\n   */\n\n  __proto.getObject = function () {\n    var nextMap = {};\n    var orderMap = this.orderMap;\n    for (var name in orderMap) {\n      nextMap[name] = orderMap[name].slice();\n    }\n    return nextMap;\n  };\n  /**\n   *\n   */\n\n  __proto.clone = function () {\n    var map = new OrderMap(this.separator);\n    map.setObject(map.orderMap);\n    return map;\n  };\n  return OrderMap;\n}();\nexport default OrderMap;","map":{"version":3,"mappings":"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","names":["separator","names","join","orderMap","getFullName","isFull","fullOrders","self","pushOrders","nextNames","stack","orders","get","forEach","nextStack","name","nextOrders","length","push","i","_this","addName","slice","set","indexOf","orderName","fullName","prevNames","lastName","splice","findIndex","callback","result","gets","filter","map","OrderMap","add","index","deleteCount","currentOrders","obj","nextMap","setObject"],"sources":["C:\\Users\\SSAFY\\Desktop\\S08P12C106\\최유경\\testing-app\\node_modules\\order-map\\src\\OrderMap.ts"],"sourcesContent":["import { IObject } from \"@daybrush/utils\";\n\n/**\n *\n */\nclass OrderMap<T = number | string> {\n    public orderMap: IObject<T[]> = {};\n\n    /**\n     *\n     */\n    constructor(private separator: string) { }\n\n    /**\n     *\n     */\n    public getFullName(names: T[]) {\n        return names.join(this.separator);\n    }\n\n    /**\n     *\n     */\n    public get(names: T[]): T[] | undefined {\n        return this.orderMap[this.getFullName(names)];\n    }\n\n    /**\n     *\n     */\n    public gets(names: T[], isFull = true): T[][] {\n        const fullOrders: T[][] = [];\n        const self = this;\n        function pushOrders(nextNames: T[], stack: T[]) {\n            const orders = self.get(nextNames);\n\n            if (!orders) {\n                return;\n            }\n            orders.forEach(name => {\n                const nextStack = [...stack, name];\n                const nextOrders = pushOrders([...nextNames, name], nextStack);\n\n                if (!nextOrders || !nextOrders.length) {\n                    fullOrders.push([...stack, name]);\n                }\n            });\n            return orders;\n        }\n\n        pushOrders(names, isFull ? names : []);\n\n        return fullOrders;\n    }\n\n    /**\n     *\n     */\n    public set(names: T[], orders: T[]): T[] {\n        names.forEach((name, i) => {\n            this.addName(names.slice(0, i), name);\n        });\n        this.orderMap[this.getFullName(names)] = orders;\n\n        return orders;\n    }\n\n    /**\n     *\n     */\n    public add(names: T[]): T[] {\n        const length = names.length;\n\n        if (!length) {\n            return [];\n        }\n        return this.addName(names.slice(0, -1), names[length - 1]);\n    }\n\n    /**\n     *\n     */\n    public addName(names: T[], name: T): T[] {\n        const orders = this.get(names) || this.set(names, []);\n\n        if (orders.indexOf(name) === -1) {\n            orders.push(name);\n        }\n        return orders;\n    }\n\n    /**\n     *\n     */\n    public findIndex(names: T[], orderName: T): number {\n        const orders = this.orderMap[this.getFullName(names)];\n\n        if (!orders) {\n            return -1;\n        }\n        return orders.indexOf(orderName);\n    }\n\n    /**\n     *\n     */\n    public remove(names: T[]): this {\n        const fullName = this.getFullName(names);\n        const orderMap = this.orderMap;\n\n        for (const name in orderMap) {\n            if (name.indexOf(fullName) === 0) {\n                delete orderMap[name];\n            }\n        }\n        const length = names.length;\n\n        if (length) {\n            const prevNames = names.slice(0, -1);\n            const lastName = names[length - 1];\n\n            this.splice(prevNames, this.findIndex(prevNames, lastName), 1);\n        }\n        return this;\n    }\n\n    /**\n     *\n     */\n    public filter(\n        names: T[],\n        callback: (value: T[], index: number, arr: T[][]) => boolean,\n        isFull = true,\n    ) {\n        const result = this.gets(names, isFull).filter(callback);\n        const map = new OrderMap<T>(this.separator);\n        const stack = isFull ? [] : names;\n\n        result.forEach(nextNames => {\n            map.add([...stack, ...nextNames]);\n        });\n\n        return map;\n    }\n\n    /**\n     *\n     */\n    public splice(names: T[], index: number, deleteCount: number, ...orders: T[]) {\n        const currentOrders = this.get(names) || this.set(names, []);\n\n        currentOrders.splice(index, deleteCount, ...orders);\n\n        return this;\n    }\n\n    /**\n     *\n     */\n    public clear() {\n        this.orderMap = {};\n    }\n\n    /**\n     *\n     */\n    public setObject(obj: IObject<T[]>) {\n        const orderMap = this.orderMap;\n\n        for (const name in obj) {\n            orderMap[name] = obj[name].slice();\n        }\n    }\n    /**\n     *\n     */\n    public getObject(): IObject<T[]> {\n        const nextMap = {};\n\n        const orderMap = this.orderMap;\n        for (const name in orderMap) {\n            nextMap[name] = orderMap[name].slice();\n        }\n        return nextMap;\n    }\n    /**\n     *\n     */\n    public clone() {\n        const map = new OrderMap<T>(this.separator);\n\n        map.setObject(map.orderMap);\n        return map;\n    }\n}\n\nexport default OrderMap;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}