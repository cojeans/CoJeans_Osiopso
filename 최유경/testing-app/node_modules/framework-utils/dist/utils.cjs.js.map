{"version":3,"file":"utils.cjs.js","sources":["../src/index.ts"],"sourcesContent":["export function prefixNames(prefix: string, ...classNames: string[]) {\n    return classNames\n        .map((className) =>\n            className\n                .split(\" \")\n                .map((name) => (name ? `${prefix}${name}` : \"\"))\n                .join(\" \")\n        )\n        .join(\" \");\n}\n\nexport function prefixCSS(prefix: string, css: string) {\n    return css.replace(/([^}{]*){/gm, (_, selector) => {\n        return `${selector.replace(/\\.([^{,\\s\\d.]+)/g, `.${prefix}$1`)}{`;\n    });\n}\n\n/* react */\nexport function ref(target: any, name: string) {\n    return (e: any) => {\n        e && (target[name] = e);\n    };\n}\nexport function refs(target: any, name: string, i: number) {\n    return (e: any) => {\n        e && (target[name][i] = e);\n    };\n}\n\n/* Class Decorator */\nexport function Properties(\n    properties: any[],\n    action: (prototype: any, property: string) => any\n) {\n    return (component: any) => {\n        const prototype = component.prototype;\n\n        properties.forEach((property) => {\n            action(prototype, property);\n        });\n    };\n}\n\n/* Property Decorator */\nexport function withMethods(\n    methods: readonly string[],\n    duplicate: { [name: string]: string } = {}\n) {\n    return (prototype: any, propertyName: string) => {\n        methods.forEach((name) => {\n            const methodName = duplicate[name] || name;\n\n            if (methodName in prototype) {\n                return;\n            }\n            prototype[methodName] = function (...args) {\n                const result = this[propertyName][name](...args);\n\n                if (result === this[propertyName]) {\n                    return this;\n                } else {\n                    return result;\n                }\n            };\n        });\n    };\n}\n\nexport type ParametersType<Func, Return> = Func extends (\n    ...params: infer Params\n) => any\n    ? (...params: Params) => Return\n    : never;\n\nexport type ExcludeInterface<Obj1, Obj2> = {\n    [key in Exclude<keyof Obj1, keyof Obj2>]: Obj1[key];\n};\n\nexport type EntriesObject<T> = {\n    [key in keyof T]: [key, Readonly<T[key]>];\n};\nexport type FindKey<E, V> = E extends [infer U, V] ? U & string : never;\nexport type InvertObject<\n    T extends Record<string, any>,\n    En extends Record<string, any> = EntriesObject<T>\n    > = {\n        [key in En[keyof En][1]]: FindKey<En[keyof En], key>\n    };\n\nexport type Entries<\n    Obj extends { [key: string]: any },\n    Key = keyof Obj\n> = Key extends string ? [Key, Obj[Key]] : never;\n\nexport type ReverseKey<\n    Key extends string,\n    Obj extends { [key: string]: any },\n    E = Entries<Obj>\n> = E extends [infer Value, Key] ? Value : never;\n\nexport type UniqueMethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any }\n> = {\n    [key in keyof ExcludeInterface<Methods, Duplicate>]: Methods[key] extends (\n        ...params: any[]\n    ) => Target\n        ? ParametersType<Methods[key], ReturnTarget>\n        : Methods[key];\n};\n\nexport type ChangedMethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any }\n> = {\n    [key in Duplicate[keyof Duplicate]]: Methods[ReverseKey<key, Duplicate> &\n        keyof Methods] extends (...params: any[]) => Target\n        ? ParametersType<\n              Methods[ReverseKey<key, Duplicate> & keyof Methods],\n              ReturnTarget\n          >\n        : Methods[ReverseKey<key, Duplicate> & keyof Methods];\n};\n\nexport type MethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any } = {}\n> = UniqueMethodInterface<Methods, Target, ReturnTarget, Duplicate> &\n    ChangedMethodInterface<Methods, Target, ReturnTarget, Duplicate>;\n"],"names":["prefixNames","prefix","_i","classNames","map","className","split","name","join","prefixCSS","css","replace","_","selector","ref","target","e","refs","i","Properties","properties","action","component","prototype","forEach","property","withMethods","methods","duplicate","propertyName","methodName","args","result","_a"],"mappings":";;;;;;;;;;SAAgBA,YAAYC;qBAAgB;;OAAA,YAAAC,uBAAAA;IAAAC,kBAAA,gBAAA;;;SACjCA,UAAU,CACZC,GADE,CACE,UAACC,SAAD;WACDA,SAAS,CACJC,KADL,CACW,GADX,EAEKF,GAFL,CAES,UAACG,IAAD;aAAWA,IAAI,GAAG,KAAGN,MAAH,GAAYM,IAAf,GAAwB,EAA7B;KAFnB,EAGKC,IAHL,CAGU,GAHV,CAAA;GAFD,EAOFA,IAPE,CAOG,GAPH,CAAP;;AAUJ,SAAgBC,UAAUR,QAAgBS;SAC/BA,GAAG,CAACC,OAAJ,CAAY,aAAZ,EAA2B,UAACC,CAAD,EAAIC,QAAJ;WACpBA,QAAQ,CAACF,OAAT,CAAiB,kBAAjB,EAAqC,MAAIV,MAAJ,OAArC,OAAV;GADG,CAAP;;;;AAMJ,SAAgBa,IAAIC,QAAaR;SACtB,UAACS,CAAD;IACHA,CAAC,KAAKD,MAAM,CAACR,IAAD,CAAN,GAAeS,CAApB,CAAD;GADJ;;AAIJ,SAAgBC,KAAKF,QAAaR,MAAcW;SACrC,UAACF,CAAD;IACHA,CAAC,KAAKD,MAAM,CAACR,IAAD,CAAN,CAAaW,CAAb,IAAkBF,CAAvB,CAAD;GADJ;;;;AAMJ,SAAgBG,WACZC,YACAC;SAEO,UAACC,SAAD;QACGC,SAAS,GAAGD,SAAS,CAACC,SAA5B;IAEAH,UAAU,CAACI,OAAX,CAAmB,UAACC,QAAD;MACfJ,MAAM,CAACE,SAAD,EAAYE,QAAZ,CAAN;KADJ;GAHJ;;;;AAUJ,SAAgBC,YACZC,SACAC;0BAAA,EAAA;IAAAA,cAAA;;;SAEO,UAACL,SAAD,EAAiBM,YAAjB;IACHF,OAAO,CAACH,OAAR,CAAgB,UAACjB,IAAD;UACNuB,UAAU,GAAGF,SAAS,CAACrB,IAAD,CAAT,IAAmBA,IAAtC;;UAEIuB,UAAU,IAAIP,SAAlB,EAA6B;;;;MAG7BA,SAAS,CAACO,UAAD,CAAT,GAAwB;;;qBAAU;;aAAA,YAAA5B,uBAAAA;UAAA6B,QAAA,gBAAA;;;YACxBC,MAAM,GAAG,CAAAC,KAAA,KAAKJ,YAAL,CAAA,EAAmBtB,IAAnB,OAAA,GAAA,EAA4BwB,IAA5B,CAAf;;YAEIC,MAAM,KAAK,KAAKH,YAAL,CAAf,EAAmC;iBACxB,IAAP;SADJ,MAEO;iBACIG,MAAP;;OANR;KANJ;GADJ;;;;;;;;;;"}