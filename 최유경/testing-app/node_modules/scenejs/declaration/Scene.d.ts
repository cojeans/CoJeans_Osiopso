import Animator from "./Animator";
import SceneItem from "./SceneItem";
import { IObject } from "@daybrush/utils";
import { AnimateElement, SceneState, SceneOptions, EasingType, AnimatorState, SceneItemOptions, PlayCondition, NameType, SceneEvents } from "./types";
import Frame from "./Frame";
import OrderMap from "order-map";
import { InjectResult, StyledInjector } from "css-styled";
/**
 * manage sceneItems and play Scene.
 * @extends Animator
 * @sort 1
 */
declare class Scene extends Animator<SceneOptions, SceneState, SceneEvents> {
    /**
    * version info
    * @type {string}
    * @example
    * Scene.VERSION // #__VERSION__#
    */
    static VERSION: string;
    items: IObject<Scene | SceneItem>;
    orderMap: OrderMap<string | number>;
    styled: StyledInjector;
    styledInjector: InjectResult;
    temp: IObject<Frame>;
    /**
    * @param - properties
    * @param - options
    * @example
    const scene = new Scene({
      item1: {
        0: {
          display: "none",
        },
        1: {
          display: "block",
          opacity: 0,
        },
        2: {
          opacity: 1,
        },
      },
      item2: {
        2: {
          opacity: 1,
        },
      }
    });
      */
    constructor(properties?: {
        options?: Partial<SceneOptions>;
    } & IObject<any>, options?: Partial<SceneOptions>);
    getDuration(): number;
    setDuration(duration: number): this;
    getItem<T extends (Scene | SceneItem) = Scene | SceneItem>(name: number | string): T;
    /**
    * create item in scene
    * @param {} name - name of item to create
    * @param {} options - The option object of SceneItem
    * @return {} Newly created item
    * @example
    const item = scene.newItem("item1")
    */
    newItem(name: number | string, options?: Partial<SceneItemOptions>): Scene | SceneItem;
    /**
    * remove item in scene
    * @param - name of item to remove
    * @return  An instance itself
    * @example
    const item = scene.newItem("item1")

    scene.removeItem("item1");
    */
    removeItem(name: number | string): this;
    /**
    * add a sceneItem to the scene
    * @param - name of item to create
    * @param - sceneItem
    * @example
    const item = scene.newItem("item1")
    */
    setItem(name: number | string, item: Scene | SceneItem): this;
    /**
    * Get the current computed frames.
    * (If needUpdate is true, get a new computed frames, not the temp that has already been saved.)
    */
    getCurrentFrames(needUpdate?: boolean, parentEasing?: EasingType): IObject<any>;
    /**
   * Get the current flatted computed frames.
   * (If needUpdate is true, get a new computed frames, not the temp that has already been saved.)
   * If there is a scene in the scene, you can get a flatted frame map.
   * @example
   * import Scene, { NAME_SEPARATOR } from "scenejs";
   *
   * {
   *   "a": Frame,
   *   "b": {
   *     "b1": Frame,
   *     "b2": Frame,
   *   },
   * }
   * const frames = scene.getCurrentFrames();
   * {
   *   "a": Frame,
   *   "b_///_b1": Frame,
   *   "b_///_b2": Frame,
   * }
   * const frames = scene.getCurrentFlattedFrames();
   *
   */
    getCurrentFlattedFrames(needUpdate?: boolean, parentEasing?: EasingType): Record<string, Frame>;
    setTime(time: number | string, isTick?: boolean, isParent?: boolean, parentEasing?: EasingType): this;
    /**
     * executes a provided function once for each scene item.
     * @param - Function to execute for each element, taking three arguments
     * @return {Scene} An instance itself
     */
    forEach(func: (item: Scene | SceneItem, id: string | number, index: number, items: IObject<Scene | SceneItem>) => void): this;
    toCSS(playCondition?: PlayCondition, duration?: number, parentStates?: AnimatorState[]): string;
    /**
     * Export the CSS of the items to the style.
     * @param - Add a selector or className to play.
     * @return {Scene} An instance itself
     */
    exportCSS(playCondition?: PlayCondition, duration?: number, parentStates?: AnimatorState[]): this;
    append(item: SceneItem | Scene): void;
    pauseCSS(): this;
    pause(): this;
    endCSS(): void;
    end(): this;
    /**
  * get item orders
  * @example
  scene.getOrders() // => ["item1", "item2"]
  */
    getOrders(): NameType[];
    /**
      * set item orders
      * @param - orders
      * @example
      frame.setOrders(["item2", "item1"]) // => ["item2", "item1"]
      */
    setOrders(orders: NameType[]): NameType[];
    getAnimationElement(): AnimateElement;
    addPlayClass(isPaused: boolean, playClassName?: string, properties?: object): AnimateElement;
    /**
    * Play using the css animation and keyframes.
    * @param - Check if you want to export css.
    * @param [playClassName="startAnimation"] - Add a class name to play.
    * @param - The shorthand properties for six of the animation properties.
    * @return {Scene} An instance itself
    * @see {@link https://www.w3schools.com/cssref/css3_pr_animation.asp}
    * @example
    scene.playCSS();
    scene.playCSS(false, {
    direction: "reverse",
    fillMode: "forwards",
    });
    */
    playCSS(isExportCSS?: boolean, playClassName?: string, properties?: Partial<AnimatorState>): this;
    set(properties: any, ...args: any[]): this;
    /**
      * Clear All Items
      * @return {Scene} An instance itself
      */
    clear(): void;
    load(properties?: any, options?: any): this;
    setOptions(options?: Partial<SceneState>): this;
    setSelector(target?: string | boolean | ((id: number | string) => string | AnimateElement)): this;
    start(delay?: number): boolean;
}
export default Scene;
